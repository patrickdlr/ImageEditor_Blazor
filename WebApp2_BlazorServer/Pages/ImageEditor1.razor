@page "/ImageEditor1"


@*@using BlazorInputFile;*@
@using SixLabors.ImageSharp;
@using System.IO;
@using SixLabors.ImageSharp.Formats;
@using System.Diagnostics;
@using SixLabors.ImageSharp.Processing;
@using SixLabors.ImageSharp.PixelFormats; @*<rgba32>*@
@using System;
@using BlazorServerApp1;
@using SixLabors.ImageSharp.Memory;
@using System.Runtime.InteropServices; @*memory marhshall*@
@using System.Numerics; @*vector4*@



@code {

    //NOTES:
    //business-oriented sfotware dev is about making use of tools to help your business stay comopetitive. ex: implement opencv photo filter, etc.

    //LIST OF PROBLEMS
    //fix the navbar, check if huesset.com is SSL secured after 24 hours (after 10:40am 5/25) ///PROBLEM 0
    //fix darken/brightness, like make it use centralized variable and original photo ///PROBLEM1
    //need to make every uploaded images act as PNG //PROBLEM2
    //update imgSharp_original, should get another imgSharp_original2 to make sure that the reset button works as intended ///PROBLEM3
    //resize/center photo better? off to the right, not well centered ///PROBLEM4
    //how to make gradual increase, not sudden increase throughout range //PROBLEM5

    string status;
    string Error;
    bool showloading = false;
    bool displayImage = false;

    Image<Rgba32> imgSharp;
    Image<Rgba32> imgSharp_original1; //used by reset
    Image<Rgba32> imgSharp_original2; //used by darken/brighten
    Image<Rgba32> imgSharp_original3; //used by other filters
    Image<Rgba32> imgSharp_underneath;
    Image<Rgba32> imgSharp_blank;

    //Image<Rgba32> imgSharp_previous_forundo;
    //Image<Rgba32> imgSharp_prior_forredo;

    ImageProcessing_CS _ip;
    ImageProcessing_CS _ip_original;
    ImageProcessing_CS _ip_underneath;
    ImageProcessing_CS _ip_blank;

    IImageFormat IIF1;
    //need to make every uploaded images act as PNG //PROBLEM2
    //IImageFormat format = image.CurrentImageFormat
    //IImageFormat IIF1;
    //IImageFormat IIF2 = SixLabors.ImageSharp.Formats.Png.PngFormat;
    //int num1 = 60;

    int brightness = 0;

    //METHOD TO be called first
    //METHOD TO be called first
    void SomeStartupMethod()
    {
        // Do Some Work
        // Make website show uploaded/sample image upon loading
        imgSharp = Image.Load<Rgba32>("wwwroot/images/wlop1.jpg", out IIF1); // imagesharp
        imgSharp_original1 = Image.Load<Rgba32>("wwwroot/images/wlop1.jpg", out IIF1);
        imgSharp_underneath = Image.Load<Rgba32>("wwwroot/images/wlop1.jpg", out IIF1); imgSharp_underneath.Mutate(x => x.Grayscale());
        imgSharp_blank = new Image<Rgba32>(imgSharp.Width, imgSharp.Height);

        _ip = new ImageProcessing_CS(imgSharp, IIF1); // imagesharp, image for img src
        _ip_original = new ImageProcessing_CS(imgSharp, IIF1);
        _ip_underneath = new ImageProcessing_CS(imgSharp_underneath, IIF1);
        _ip_blank = new ImageProcessing_CS(imgSharp_blank, IIF1);

        displayImage = true;
    }

    Task SomeStartupTask()
    {
        // Do some task based work
        return Task.CompletedTask;
    }
    protected override async Task OnInitializedAsync()
    {
        await Task.Delay(1);
        SomeStartupMethod();
        await SomeStartupTask();
    }
    //METHOD TO be called first
    //METHOD TO be called first
}



<h1>Image Editor</h1>
@*<p>Upload an image: <InputFile OnChange="HandleFileSelected_function" /></p>*@
<p>Note: Uploading/editing an image may take >45 seconds. For best results from line filter, use images with blank background, high resolution, and/or semi-realistic art style. </p>

@if (showloading == true)
{<p style="color:greenyellow">Uploading...</p>}

<div>
    <button class="btn btn-primary" @onclick="Filter1">No Red</button>
    <button class="btn btn-primary" @onclick="Filter2">No Green</button>
    <button class="btn btn-primary" @onclick="Filter3">No Blue</button>
    <br />

    <button class="btn btn-primary" @onclick="Brighten">Brightness (+)</button>
    <button class="btn btn-primary" @onclick="Darken">Brightness (-)</button>
    <br />

    <button class="btn btn-primary" @onclick="Opaque">Opacity (+)</button>
    <button class="btn btn-primary" @onclick="Transparent">Opacity (-)</button>
    Note: Opacity adjustment only works on PNG, not JPG/JPEG, for now.
    <br />

    <button class="btn btn-primary" @onclick="Grayscale">Grayscale</button>
    <button class="btn btn-primary" @onclick="Edge">Line</button>
    @*<button class="btn btn-primary" @onclick="Transparentbackgroundtf_function">Transparent background for Edge: @transparentbackgroundtf</button>*@
    <br />

    <button class="btn btn-primary" @onclick="Reset">Reset</button>
    <br />

    @*<button class="btn btn-primary">Undo (coming soon)</button>
        <button class="btn btn-primary">Redo (coming soon)</button>
        <br />*@

</div>


@if (displayImage == true)
{
    <h5>@status</h5>

    <p>

        <div>
            @*<img class="image_background" src="@_ip_blank.getBase64String_function()" /> not needed*@
            @*<img class="image_display" src="@_ip_underneath.getBase64String_function()" />*@
            <img class="image_display"
                 src="@_ip.getBase64String_function()" />
        </div>
        <br />



    </p>
}



@code {

    bool transparentbackgroundtf = true;
    //void Transparentbackgroundtf_function()
    //{
    //    if (transparentbackgroundtf == false)
    //    {
    //        transparentbackgroundtf = true;
    //    }
    //    else
    //    {
    //        transparentbackgroundtf = false;
    //    }
    //}




    //pixel manipulation way 1
    //(not storing variable)
    void Filter1()
    {
        if (displayImage == true)
        {
            for (int w = 0; w < imgSharp.Width; w++)
            {
                for (int h = 0; h < imgSharp.Height; h++)
                {
                    //if (imgSharp[w, h].R < 120)
                    //    imgSharp[w, h] = new Rgba32(255, imgSharp[w, h].G, imgSharp[w, h].B, 255);
                    imgSharp[w, h] = new Rgba32(45, imgSharp_original1[w, h].G, imgSharp_original1[w, h].B, imgSharp_original1[w, h].A);
                }
            }
        }
    }

    //pixel manipulation way 1
    //(storing variable)
    //gives problem, gives white/bright colors (possible solultion, use int and byte) //solved with byte type
    void Filter2()
    {
        if (displayImage == true)
        {
            for (int w = 0; w < imgSharp.Width; w++)
            {
                for (int h = 0; h < imgSharp.Height; h++)
                {
                    //int green = imgSharp[w, h].G - 10;
                    //if (green < 45) { green = 45; }
                    //byte green2 = (byte)green; //use byte
                    //imgSharp[w, h] = new Rgba32(imgSharp[w, h].R, green2, imgSharp[w, h].B, imgSharp[w, h].A);

                    imgSharp[w, h] = new Rgba32(imgSharp_original1[w, h].R, 45, imgSharp_original1[w, h].B, imgSharp_original1[w, h].A);
                }
            }
        }

    }


    //pixel manipulation way 2
    //(not storing variable)
    void Filter3()
    {
        if (displayImage == true)
        {
            for (int y = 0; y < imgSharp.Height; y++)
            {
                Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
                for (int x = 0; x < imgSharp.Width; x++)
                {
                    pixelRowSpan[x] = new Rgba32(imgSharp_original1[x, y].R, imgSharp_original1[x, y].G, 45, imgSharp_original1[x, y].A);
                }
            }
        }
    }






    //pixel manipulation way 2
    //(storing variable)
    public void Darken()
    {
        if (displayImage == true)
        {
            brightness -= 20;
            int red;
            byte red2;
            int green;
            byte green2;
            int blue;
            byte blue2;

            for (int y = 0; y < imgSharp.Height; y++)
            {
                Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
                for (int x = 0; x < imgSharp.Width; x++)
                {
                    red = imgSharp_original1[x, y].R + brightness;
                    green = imgSharp_original1[x, y].G + brightness;
                    blue = imgSharp_original1[x, y].B + brightness;

                    if (red > 255) { red = 255; }
                    else if (red < 0) { red = 0; }
                    if (green > 255) { green = 255; }
                    else if (green < 0) { green = 0; }
                    if (blue > 255) { blue = 255; }
                    else if (blue < 0) { blue = 0; }

                    red2 = (byte)red;
                    green2 = (byte)green;
                    blue2 = (byte)blue;

                    pixelRowSpan[x] = new Rgba32(red2, green2, blue2, imgSharp[x, y].A);
                }
            }
        }
        //Debug.WriteLine(blue);
        //imgSharp_original3 = imgSharp_original2;

    }

    //pixel manipulation way 2
    //(storing variable)
    //fix brighten and darken as color get washed out, maybe stop brightening or darkening if one color reaches 255 or 0, or always start from original image and then adjust it using current "multiplier"
    public void Brighten()
    {
        if (displayImage == true)
        {
            brightness += 20;
            int red;
            byte red2;
            int green;
            byte green2;
            int blue;
            byte blue2;

            for (int y = 0; y < imgSharp.Height; y++)
            {
                Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
                for (int x = 0; x < imgSharp.Width; x++)
                {
                    red = imgSharp_original1[x, y].R + brightness;
                    green = imgSharp_original1[x, y].G + brightness;
                    blue = imgSharp_original1[x, y].B + brightness;

                    if (red > 255) { red = 255; }
                    else if (red < 0) { red = 0; }
                    if (green > 255) { green = 255; }
                    else if (green < 0) { green = 0; }
                    if (blue > 255) { blue = 255; }
                    else if (blue < 0) { blue = 0; }

                    red2 = (byte)red;
                    green2 = (byte)green;
                    blue2 = (byte)blue;

                    pixelRowSpan[x] = new Rgba32(red2, green2, blue2, imgSharp[x, y].A);
                }
            }
        }
        //Debug.WriteLine(blue);
    }



    //pixel manipulation way 2
    //(storing variable)
    public void Opaque()
    {
        if (displayImage == true)
        {
            int alpha;
            byte alpha2;

            for (int y = 0; y < imgSharp.Height; y++)
            {
                Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
                for (int x = 0; x < imgSharp.Width; x++)
                {
                    alpha = imgSharp[x, y].A + 20;
                    if (alpha > 255) { alpha = 255; }
                    else if (alpha < 0) { alpha = 0; }
                    alpha2 = (byte)alpha;

                    pixelRowSpan[x] = new Rgba32(imgSharp[x, y].R, imgSharp[x, y].G, imgSharp[x, y].B, alpha2);
                }
            }
        }
        //imgSharp_original2 = imgSharp;
    }


    //pixel manipulation way 2
    //(storing variable)
    public void Transparent()
    {
        if (displayImage == true)
        {
            int alpha;
            byte alpha2;

            for (int y = 0; y < imgSharp.Height; y++)
            {
                Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
                for (int x = 0; x < imgSharp.Width; x++)
                {
                    alpha = imgSharp[x, y].A - 20;
                    if (alpha > 255) { alpha = 255; }
                    else if (alpha < 0) { alpha = 0; }
                    alpha2 = (byte)alpha;

                    pixelRowSpan[x] = new Rgba32(imgSharp[x, y].R, imgSharp[x, y].G, imgSharp[x, y].B, alpha2);
                }
            }
        }
        //imgSharp_original2 = imgSharp;
    }





    //pixel manipulation way 1
    //(storing variable)
    //grayscale filter
    void Grayscale()
    {
        //if (displayImage == true)
        //{
        //    for (int w = 0; w < imgSharp.Width; w++)
        //    {
        //        for (int h = 0; h < imgSharp.Height; h++)
        //        {
        //            int bwcolor = (imgSharp[w, h].R + imgSharp[w, h].G + imgSharp[w, h].B) / 3;
        //            byte bwcolor2 = (byte)bwcolor;

        //            imgSharp[w, h] = new Rgba32(bwcolor2, bwcolor2, bwcolor2, imgSharp[w, h].A);
        //        }
        //    }
        //}
        //imgSharp = imgSharp_original;
        imgSharp.Mutate(x => x.Grayscale());
    }




    ////lambda way
    //Console.WriteLine("--");
    //list2.ForEach((a) => Console.WriteLine(a));

    //// for each
    //foreach (var i in list2)
    //{
    //    Console.WriteLine(i.ToString());
    //}

    //pixel manipulation way 3 pixel agnostic (dicphering)
    // 16 = height
    //row.Length: 11 (15) = repeats 16 times, starting from (0) to (15)
    //w: 0, 1, 2, 3.. 10 (0)
    //w: 0, 1, 2, 3.. 10 (1)
    //w: 0, 1, 2, 3.. 10 (2)
    //w: 0, 1, 2, 3.. 10 (3)
    //w: 0, 1, 2, 3.. 10
    //w: 0, 1, 2, 3.. 10
    //...
    //w: 0, 1, 2, 3.. 10 (15)






    //WIP, use way 2,
    //works on small image

    void Edge()
    {
        if (displayImage == true)
        {
            int height = imgSharp.Height - 1;
            int width = imgSharp.Width - 1; //preivious -1


            int[,] array_gx = new int[3, 3];
            array_gx[0, 0] = -1; array_gx[0, 1] = 0; array_gx[0, 2] = 1;
            array_gx[1, 0] = -2; array_gx[1, 1] = 0; array_gx[1, 2] = 2;
            array_gx[2, 0] = -1; array_gx[2, 1] = 0; array_gx[2, 2] = 1;
            int[,] array_gy = new int[3, 3];
            array_gy[0, 0] = -1; array_gy[0, 1] = -2; array_gy[0, 2] = -1;
            array_gy[1, 0] = 0; array_gy[1, 1] = 0; array_gy[1, 2] = 0;
            array_gy[2, 0] = 1; array_gy[2, 1] = 2; array_gy[2, 2] = 1;

            //init
            int val_Alpha = 0;
            byte val_Alpha2 = 0;

            int val_Blue = 0;
            int val_Green = 0;
            int val_Red = 0;

            int Gx_sum_Blue = 0;
            int Gx_sum_Green = 0;
            int Gx_sum_Red = 0;

            int Gy_sum_Blue = 0;
            int Gy_sum_Green = 0;
            int Gy_sum_Red = 0;

            int Gxy_sum_final_Blue = 0;
            int Gxy_sum_final_Green = 0;
            int Gxy_sum_final_Red = 0;

            //int logprint_sum1 = 0;



            for (int y = 0; y <= height; y++)
            {
                Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
                for (int x = 0; x <= width; x++)
                {

                    Gx_sum_Blue = 0;
                    Gx_sum_Green = 0;
                    Gx_sum_Red = 0;

                    Gy_sum_Blue = 0;
                    Gy_sum_Green = 0;
                    Gy_sum_Red = 0;

                    Gxy_sum_final_Blue = 0;
                    Gxy_sum_final_Green = 0;
                    Gxy_sum_final_Red = 0;

                    //// finding Gx and Gy
                    //// finding Gx and Gy
                    for (int r = 0; r < 3; r++)
                    {
                        for (int c = 0; c < 3; c++)
                        {
                            //fix this part, so it can work on any image on BS1 app
                            if (((y + (r - 1) >= 0) && (x + (c - 1) >= 0)) && ((y + (r - 1) <= height) && (x + (c - 1) <= width)))
                            {
                                int he = y + (r - 1);
                                int we = x + (c - 1);

                                //val_Blue = imgSharp[he, we].B;
                                //val_Green = imgSharp[he, we].G;
                                //val_Red = imgSharp[he, we].R;

                                val_Blue = imgSharp_original1[we, he].B;
                                val_Green = imgSharp_original1[we, he].G;
                                val_Red = imgSharp_original1[we, he].R;
                            }
                            //fix this part, so it can work on any image on BS1 app


                            // if outside the border (row)
                            if ((y + (r - 1) < 0) || (y + (r - 1) > (height - 1)))
                            {
                                val_Blue = 0;
                                val_Green = 0;
                                val_Red = 0;
                                //logprint_sum1++; //2400
                            }

                            // if outside the border (column)
                            // 400
                            else if ((x + (c - 1) < 0) || (x + (c - 1) > (width - 1)))
                            {
                                val_Blue = 0;
                                val_Green = 0;
                                val_Red = 0;
                                //logprint_sum1++; //3290
                            }

                            Gx_sum_Blue += val_Blue * array_gx[r, c];
                            Gx_sum_Green += val_Green * array_gx[r, c];
                            Gx_sum_Red += val_Red * array_gx[r, c];

                            Gy_sum_Blue += val_Blue * array_gy[r, c];
                            Gy_sum_Green += val_Green * array_gy[r, c];
                            Gy_sum_Red += val_Red * array_gy[r, c];

                        }
                    }
                    //// finding Gx and Gy
                    //// finding Gx and Gy



                    //store alpha for desired modification
                    val_Alpha = imgSharp[x, y].A;

                    Gxy_sum_final_Blue = (int)Math.Sqrt(((Math.Pow(Gx_sum_Blue, 2)) + (Math.Pow(Gy_sum_Blue, 2))));
                    Gxy_sum_final_Green = (int)(Math.Sqrt((Math.Pow(Gx_sum_Green, 2)) + (Math.Pow(Gy_sum_Green, 2))));
                    Gxy_sum_final_Red = (int)Math.Sqrt(((Math.Pow(Gx_sum_Red, 2)) + (Math.Pow(Gy_sum_Red, 2))));


                    ////modification BEG
                    ////modification BEG

                    ////how to make gradual increase, not sudden increase throughout range //PROBLEM5
                    ////make subtle white lines lighter (applies to black background/white line sobel edge, non-invert) //way 1
                    //if (Gxy_sum_final_Blue >= 45 && Gxy_sum_final_Blue <= 83) { Gxy_sum_final_Blue = Gxy_sum_final_Blue + 15; }
                    //if (Gxy_sum_final_Green >= 45 && Gxy_sum_final_Green <= 83) { Gxy_sum_final_Green = Gxy_sum_final_Green + 15; }
                    //if (Gxy_sum_final_Red >= 45 && Gxy_sum_final_Red <= 83) { Gxy_sum_final_Red = Gxy_sum_final_Red + 15; }
                    //if (Gxy_sum_final_Blue >= 84 && Gxy_sum_final_Blue <= 122) { Gxy_sum_final_Blue = Gxy_sum_final_Blue + 30; }
                    //if (Gxy_sum_final_Green >= 84 && Gxy_sum_final_Green <= 122) { Gxy_sum_final_Green = Gxy_sum_final_Green + 30; }
                    //if (Gxy_sum_final_Red >= 84 && Gxy_sum_final_Red <= 122) { Gxy_sum_final_Red = Gxy_sum_final_Red + 30; }
                    //if (Gxy_sum_final_Blue >= 123 && Gxy_sum_final_Blue <= 160) { Gxy_sum_final_Blue = Gxy_sum_final_Blue + 45; }
                    //if (Gxy_sum_final_Green >= 123 && Gxy_sum_final_Green <= 160) { Gxy_sum_final_Green = Gxy_sum_final_Green + 45; }
                    //if (Gxy_sum_final_Red >= 123 && Gxy_sum_final_Red <= 160) { Gxy_sum_final_Red = Gxy_sum_final_Red + 45; }
                    ////make strong white lines darker (applies to black background/white line sobel edge, non-invert) //way 1
                    //if (Gxy_sum_final_Blue >= 180 && Gxy_sum_final_Blue <= 230) { Gxy_sum_final_Blue = Gxy_sum_final_Blue - 5; }
                    //if (Gxy_sum_final_Green >= 180 && Gxy_sum_final_Green <= 230) { Gxy_sum_final_Green = Gxy_sum_final_Green - 5; }
                    //if (Gxy_sum_final_Red >= 180 && Gxy_sum_final_Red <= 230) { Gxy_sum_final_Red = Gxy_sum_final_Red - 5; }
                    ////how to make gradual increase, not sudden increase throughout range //PROBLEM5

                    //make subtle white lines lighter (applies to black background/white line sobel edge, non-invert) //way 2
                    if (Gxy_sum_final_Blue >= 45 && Gxy_sum_final_Blue <= 160) { Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue * 1.50); }
                    if (Gxy_sum_final_Green >= 45 && Gxy_sum_final_Green <= 160) { Gxy_sum_final_Green = (int)(Gxy_sum_final_Green * 1.50); }
                    if (Gxy_sum_final_Red >= 45 && Gxy_sum_final_Red <= 160) { Gxy_sum_final_Red = (int)(Gxy_sum_final_Red * 1.50); }
                    //make strong white lines darker (applies to black background/white line sobel edge, non-invert) //way 2
                    if (Gxy_sum_final_Blue >= 180 && Gxy_sum_final_Blue <= 230) { Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue * 0.90); }
                    if (Gxy_sum_final_Green >= 180 && Gxy_sum_final_Green <= 230) { Gxy_sum_final_Green = (int)(Gxy_sum_final_Green * 0.90); }
                    if (Gxy_sum_final_Red >= 180 && Gxy_sum_final_Red <= 230) { Gxy_sum_final_Red = (int)(Gxy_sum_final_Red * 0.90); }


                    //ui idea
                    //idea: set a range (ex: 80-200) for weak white lines to get whiter
                    //idea: set another range (ex: 200-255) for strong white lines to get darker
                    ////modification END
                    ////modification END








                    //////custom color background
                    //int cutoff = 30; //should try make a slider ouit of this //IDEA1 //make alpha=0 background //30, 45, 60, 75
                    //if (Gxy_sum_final_Blue <= cutoff && Gxy_sum_final_Green <= cutoff && Gxy_sum_final_Red <= cutoff)
                    //{

                    //    Gxy_sum_final_Blue = 0;
                    //    Gxy_sum_final_Green = 0;
                    //    Gxy_sum_final_Red = 0;
                    //}
                    //else
                    //{
                    //    //if (Gxy_sum_final_Blue < cutoff) { Gxy_sum_final_Blue = cutoff; }
                    //    //if (Gxy_sum_final_Green < cutoff) { Gxy_sum_final_Green = cutoff; }
                    //    //if (Gxy_sum_final_Red < cutoff) { Gxy_sum_final_Red = cutoff; }
                    //    //Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue * 1.33);
                    //    //Gxy_sum_final_Green = (int)(Gxy_sum_final_Green * 1.33);
                    //    //Gxy_sum_final_Red = (int)(Gxy_sum_final_Red * 1.33);
                    //}
                    //OR..
                    //////..transparant (before invert)
                    //int cutoff = 128; //should try make a slider ouit of this //IDEA1 //make alpha=0 background //180 FOR TRANSPARRENCY
                    //if (Gxy_sum_final_Blue <= cutoff && Gxy_sum_final_Green <= cutoff && Gxy_sum_final_Red <= cutoff)
                    //{
                    //    val_Alpha = 0;
                    //}
                    //else
                    //{
                    //    //if (Gxy_sum_final_Blue < cutoff) { Gxy_sum_final_Blue = cutoff; }
                    //    //if (Gxy_sum_final_Green < cutoff) { Gxy_sum_final_Green = cutoff; }
                    //    //if (Gxy_sum_final_Red < cutoff) { Gxy_sum_final_Red = cutoff; }
                    //    Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue * 1/0.20); //should make sliders out of these //IDEA2 ex: 100% = 1, 200% = 2
                    //    Gxy_sum_final_Green = (int)(Gxy_sum_final_Green * 1/0.20);
                    //    Gxy_sum_final_Red = (int)(Gxy_sum_final_Red * 1/0.20);
                    //}


                    //keep ARGB within 0-255
                    if (Gxy_sum_final_Blue > 255) { Gxy_sum_final_Blue = 255; }
                    if (Gxy_sum_final_Green > 255) { Gxy_sum_final_Green = 255; }
                    if (Gxy_sum_final_Red > 255) { Gxy_sum_final_Red = 255; }
                    if (Gxy_sum_final_Blue < 0) { Gxy_sum_final_Blue = 0; }
                    if (Gxy_sum_final_Green < 0) { Gxy_sum_final_Green = 0; }
                    if (Gxy_sum_final_Red < 0) { Gxy_sum_final_Red = 0; }


                    //modification BEG
                    //modification BEG
                    //INVERT
                    Gxy_sum_final_Red = 255 - Gxy_sum_final_Red;
                    Gxy_sum_final_Green = 255 - Gxy_sum_final_Green;
                    Gxy_sum_final_Blue = 255 - Gxy_sum_final_Blue;



                    ////////..transparant (after invert)
                    int cutoff = 128; //should try make a slider ouit of this //IDEA1 //make alpha=0 background //180 FOR TRANSPARRENCY
                    if (Gxy_sum_final_Blue >= cutoff && Gxy_sum_final_Blue >= cutoff && Gxy_sum_final_Blue >= cutoff)
                    {
                        val_Alpha = 0;
                    }
                    else
                    {
                        Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue * 0.90); //should make sliders out of these //IDEA2 ex: 100% = 1, 200% = 2
                        Gxy_sum_final_Green = (int)(Gxy_sum_final_Green * 0.90);
                        Gxy_sum_final_Red = (int)(Gxy_sum_final_Red * 0.90);
                        //if (Gxy_sum_final_Blue > cutoff) { Gxy_sum_final_Blue = cutoff; }
                        //if (Gxy_sum_final_Green > cutoff) { Gxy_sum_final_Green = cutoff; }
                        //if (Gxy_sum_final_Red > cutoff) { Gxy_sum_final_Red = cutoff; }
                    }



                    ////Make BW
                    int bwcolor = (Gxy_sum_final_Blue + Gxy_sum_final_Green + Gxy_sum_final_Red) / 3;
                    Gxy_sum_final_Blue = bwcolor;
                    Gxy_sum_final_Green = bwcolor;
                    Gxy_sum_final_Red = bwcolor;

                    //modification END
                    //modification END



                    int bwcolor2 = (((imgSharp_original1[x, y].R + imgSharp_original1[x, y].G + imgSharp_original1[x, y].B) / 3));
                    //add shade
                    if (bwcolor2 <= bwcolor)
                        Gxy_sum_final_Blue = bwcolor2;
                    Gxy_sum_final_Green = bwcolor2;
                    Gxy_sum_final_Red = bwcolor2;
                    //int cutoff2 = 120;
                    //if (imgSharp_original1[x, y].R < cutoff2 && imgSharp_original1[x, y].G < cutoff2 && imgSharp_original1[x, y].B < cutoff2 && cutoff2 > bwcolor)
                    //{
                    //    bwcolor = (int)(((imgSharp_original1[x, y].R + imgSharp_original1[x, y].G + imgSharp_original1[x, y].B) / 3)*3);
                    //    Gxy_sum_final_Blue = bwcolor;
                    //    Gxy_sum_final_Green = bwcolor;
                    //    Gxy_sum_final_Red = bwcolor;
                    //    val_Alpha = 255;
                    //}

                    //keep ARGB within 0-255
                    if (Gxy_sum_final_Blue > 255) { Gxy_sum_final_Blue = 255; }
                    if (Gxy_sum_final_Green > 255) { Gxy_sum_final_Green = 255; }
                    if (Gxy_sum_final_Red > 255) { Gxy_sum_final_Red = 255; }
                    if (Gxy_sum_final_Blue < 0) { Gxy_sum_final_Blue = 0; }
                    if (Gxy_sum_final_Green < 0) { Gxy_sum_final_Green = 0; }
                    if (Gxy_sum_final_Red < 0) { Gxy_sum_final_Red = 0; }


                    //recreate with byte variables cuz ImageSharp
                    byte Gxy_sum_final_Red2 = (byte)Gxy_sum_final_Red;
                    byte Gxy_sum_final_Green2 = (byte)Gxy_sum_final_Green;
                    byte Gxy_sum_final_Blue2 = (byte)Gxy_sum_final_Blue;
                    val_Alpha2 = (byte)val_Alpha;





                    pixelRowSpan[x] = new Rgba32(Gxy_sum_final_Red2, Gxy_sum_final_Green2, Gxy_sum_final_Blue2, val_Alpha2);
                }
            }

            ////update imgSharp_original, should get another imgSharp_original2 to make sure that the reset button works as intended ///PROBLEM3
            //imgSharp_original1 = imgSharp;

        }
    }


    void Undo()
    {
        if (displayImage == true)
        {
        }
    }

    void Redo()
    {
        if (displayImage == true)
        {
        }
    }

    void Reset()
    {
        if (displayImage == true)
        {
            for (int y = 0; y < imgSharp.Height; y++)
            {
                Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
                for (int x = 0; x < imgSharp.Width; x++)
                {
                    pixelRowSpan[x] = new Rgba32(imgSharp_original1[x, y].R, imgSharp_original1[x, y].G, imgSharp_original1[x, y].B, imgSharp_original1[x, y].A);
                }
            }
        }
    }


    public void Dispose()
    {
    }





    ////take in file input and create imagesharp
    //async Task HandleFileSelected_function(IFileListEntry[] files) // blazorinputfile
    //{
    //    showloading = true;
    //    var imageFile = files.FirstOrDefault(); // blazorinputfile

    //    if (imageFile != null) // blazorinputfile
    //    {
    //        var ms = new MemoryStream(); // blazorinputfile
    //        await imageFile.Data.CopyToAsync(ms); // blazorinputfile



    //        ///ADDED
    //        try
    //        {
    //            //IImageFormat IIF1; // imagesharp
    //            imgSharp = Image.Load<Rgba32>(ms.ToArray(), out IIF1); // imagesharp
    //            imgSharp_original1 = Image.Load<Rgba32>(ms.ToArray(), out IIF1);
    //            imgSharp_underneath = Image.Load<Rgba32>(ms.ToArray(), out IIF1);

    //            imgSharp_underneath.Mutate(x => x.Grayscale());
    //            imgSharp_blank = new Image<Rgba32>(imgSharp.Width, imgSharp.Height);


    //            _ip = new ImageProcessing_CS(imgSharp, IIF1); // imagesharp, image for img src
    //            _ip_original = new ImageProcessing_CS(imgSharp, IIF1);
    //            _ip_underneath = new ImageProcessing_CS(imgSharp_underneath, IIF1);
    //            _ip_blank = new ImageProcessing_CS(imgSharp_blank, IIF1);


    //            displayImage = true;

    //            status = $"Finished loading {imageFile.Size} bytes from {imageFile.Name}";
    //            showloading = false;




    //            Debug.WriteLine(IIF1);
    //            //SixLabors.ImageSharp.Formats.Png.PngFormat works with transparency
    //            //SixLabors.ImageSharp.Formats.Jpeg.JpegFormat does not
    //        }


    //        catch (Exception e)
    //        {
    //            Error = $"Error occured while loading image {e.Message}";
    //            showloading = false;
    //        }

    //        ///ADDED


    //    }
    //}



}
   
