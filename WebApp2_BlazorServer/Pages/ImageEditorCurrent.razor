@page "/ImageEditorCurrent"
@*
	//Application ideas
	////make Reddit/Twitter scraper, build an past-performance analytic (rising mentions vs. stock/crypto price vs. Google trend)
	////Make stock tracker with SignalR
	////Make anime pose app that tracks your body pose

	//

	//NOTES:
	//business-oriented sfotware dev is about making use of tools to help your business stay comopetitive. ex: implement opencv photo filter, etc.
	////SixLabors.ImageSharp.Formats.Png.PngFormat works with transparency, while SixLabors.ImageSharp.Formats.Jpeg.JpegFormat does not
	Huesset's WishLIst:
	Build a robot, VR/AR entertainment apps, useful apps for artists, web scrapers, and hair clipper
	Acquire drawing, barber, and math skills for software dev
	Master value investing for possible financial freedom


	//


	//LIST OF PROBLEMS
	//Implement incremental photo filter apply "system" covering brightness/contrast/exposure
	//Make blazor faster, check if SignalR is good to speed up your image editor app, implement SignalR (important)
	//need to make every uploaded images act as PNG // //make any photo support ARGB or turn into PNG upon upload (to make ccapable of going transparant) //PROBLEM2
	//add processing status.. like "processing... estimated time: 10-40 seconds" (add counter)
	//resize/center photo better? off to the right, not well centered ///PROBLEM4
	//prevent zooming in on iPhone

	//SUGGESTED FEATURES FOR IMAGE EDITOR (user experience)
	//improve navbar to make it only show at the top rather on the side
	//need to accept only pictures; not PDFs, videos, etc. on iPhone
	//add white and black background button
	//add custom icon (on the tab in Google Chrome)
	//add 2 more sample images, such as INUY.PNG, god of war evil guy.PNG, etc.
	//add send a message to Patrick's email or database
	//disable button when image is loading or peocessing (greyed out button)
	//add button to scroll webpage to exact point for you (helps people scroll to image quickly without using their hands)
	//prevent webpage from resetting when exiting or clicking on other tab/button/link, aka keep the state same for x hours maximum
	//add photo compression percentage (for faster processing, and lower quality)
	//add gamma, incremental invert, besides brightness, contrast


	//SUGGESTED FEATURES FOR IMAGE EDITOR (logic)
	//add contrast filter (if grayscale > 128: -20, else if grayscale <= 128: +20)
	//add exposure filer (if grayscale > 128: + 20 // if grayscale > 128: -20)
	//add incrementals filters: incremental no-red/green/blue, gaussian blur,
	//add new filters: invert, sephia, improved line+shade, 8/16/32/64/128/256 bit filter
	//add brightness/contrast/exposure finalization button
	//add descale/compress image if possible
	//implement pan zoom (try timmywill)
	//add 2d spheres
	//edit 2 images individually
	//show history of filters applied
	//add buffering for image uploading and processing?
	//add recording feature (records users' orders of image filter applications)

	//Completed/ignore
	//fix the navbar, check if huesset.com is SSL secured after 24 hours (after 10:40am 5/25) ///PROBLEM 0 (DONE)
	//update imgSharp_original, should get another imgSharp_original2 to make sure that the reset button works as intended ///PROBLEM3
	//how to make gradual increase, not sudden increase throughout range //PROBLEM5

*@


@*@using BlazorInputFile; obsolate*@
@using System;
@using SixLabors.ImageSharp;
@using System.IO;
@using SixLabors.ImageSharp.Formats;
@using System.Diagnostics;
@using SixLabors.ImageSharp.Processing;
@using SixLabors.ImageSharp.PixelFormats; @*<rgba32>*@
@using BlazorServerApp1;
@using Microsoft.AspNetCore.Components.Forms;
@inject IJSRuntime JS

@*not needed?*@
@using System.Numerics; @*vector4*@
@using Microsoft.AspNetCore.Hosting;
@using SixLabors.ImageSharp.Memory;
@using System.Runtime.InteropServices; @*memory marhshall*@
@*using Microsoft.Extensions.Logging*@
@*inject IWebHostEnvironment Environment*@


@*################################################################################*@
@*################################################################################*@
@*################################################################################*@
@*################################################################################*@
@*################################################################################*@
@*################################################################################*@
@*################################################################################*@
@*################################################################################*@
@*################################################################################*@
@*################################################################################*@
@*################################################################################*@
@*################################################################################*@
@*################################################################################*@
@*################################################################################*@
@*################################################################################*@


@code {
	string status = "Sample image";
	string Error;
	bool displayImage = false;
	bool showloading = false;
	bool showprocessing = false;
	bool showerror = false;
	bool is_FilterIncremental = false;

	Image<Rgba32> imgSharp;
	Image<Rgba32> imgSharp_original1; //used by reset
	Image<Rgba32> imgSharp_original2; //used by incremental filters
	IImageFormat IIF1;

	Dictionary<string, double> DictV = new Dictionary<string, double>();

	//undo lists
	List<Image<Rgba32>> imgSharplist_undo = new List<Image<Rgba32>>();
	List<double> IncV_undo = new List<double>(); //0 = false, 1 = true
	List<double> ContrastV_undo = new List<double>();
	List<double> BrightnessV_undo = new List<double>();
	List<double> OpacityV_undo = new List<double>();
	List<double> RedV_undo = new List<double>();
	List<double> GreenV_undo = new List<double>();
	List<double> BlueV_undo = new List<double>();

	//redo lists
	List<Image<Rgba32>> imgSharplist_redo = new List<Image<Rgba32>>();
	List<double> IncV_redo = new List<double>();
	List<double> ContrastV_redo = new List<double>();
	List<double> BrightnessV_redo = new List<double>();
	List<double> OpacityV_redo = new List<double>();
	List<double> RedV_redo = new List<double>();
	List<double> GreenV_redo = new List<double>();
	List<double> BlueV_redo = new List<double>();


	////log
	string infolog1;
	string infolog2;
	double brushsize = 0;
	int imgSharpvHeight = 0;
	int imgSharpvWidth = 0;


	//METHOD TO be called first
	//METHOD TO be called first
	//METHOD TO be called first
	//METHOD TO be called first
	protected override async Task OnInitializedAsync()
	{
		await Task.Delay(1);

		// Do Some Work
		// Do Some Work
		// Make website show uploaded/sample image upon loading

		////way1
		using (var imgSharp = Image.Load<Rgba32>("wwwroot/images/wlop1.jpg")) // imagesharp
		{
			imgSharp.Save("wwwroot/images/download.png");
		}
		imgSharp = Image.Load<Rgba32>("wwwroot/images/download.png", out IIF1);
		imgSharp_original1 = Image.Load<Rgba32>("wwwroot/images/download.png", out IIF1);
		imgSharp_original2 = Image.Load<Rgba32>("wwwroot/images/download.png", out IIF1);

		////way2
		//imgSharp = Image.Load<Rgba32>("wwwroot/images/wlop1.jpg", out IIF1);
		//imgSharp_original1 = Image.Load<Rgba32>("wwwroot/images/wlop1.jpg", out IIF1);
		//imgSharp_original2 = Image.Load<Rgba32>("wwwroot/images/wlop1.jpg", out IIF1);

		imgSharpvHeight = imgSharp.Height; imgSharpvWidth = imgSharp.Width;

		displayImage = true;

		DictV.Add("IncV", 0); //0 = false, 1 = true
		DictV.Add("ContrastV", 0);
		DictV.Add("BrightnessV", 0);
		DictV.Add("OpacityV", 0);
		DictV.Add("RedV", 0);
		DictV.Add("GreenV", 0);
		DictV.Add("BlueV", 0);

	}
	//METHOD TO be called first
	//METHOD TO be called first
	//METHOD TO be called first
	//METHOD TO be called first

}

<h1>Image Editor</h1>

<div>
	@infolog1<br />
	@infolog2<br />
	Height: @imgSharpvHeight<br />
	Width: @imgSharpvWidth<br />
	Brushsize for OilPaint: @brushsize<br />
</div>

<form>
	<figcaption>
		Upload an image (15 MB max):
	</figcaption>
	<InputFile id="InputFileID" OnChange="@UploadFile" />

	@*<p>Upload an image (OLD): <InputFile OnChange="HandleFileSelected_function" /></p>*@
	@*only available in Net 5.0, so use net 5.0 and ensure that ur fully migrated to net 5.0~!!!!*@
	@*<input multiple="" type="file" _bl_2="">*@
</form>


<div>
	@if (showloading == true)
	{<p style="color:greenyellow">Uploading...</p>}
	@if (showloading == false)
	{<p>@status</p>}
	@if (showprocessing == true)
	{<p style="color:darkorange">Processing...</p>}
	@if (showerror == true)
	{<p style="color:red">@Error</p>}
</div>


<div>
	<figcaption>Filters (more to be added): </figcaption>
	<button class="btn btn-primary" @onclick="InformationLog">Log List</button>

	@*filters to fix*@
	<button class="btn btn-primary" @onclick="Filter1">Filter1</button>
	<button class="btn btn-primary" @onclick="Filter2">Filter2</button>
	@*<button class="btn btn-primary" @onclick="OpacityUP">Opacity (+)</button>
	<button class="btn btn-primary" @onclick="OpacityDOWN">Opacity (-)</button>*@
	Note: Opacity adjustment only works on PNG, not JPG/JPEG, for now.
	<br />

	<button class="btn btn-primary" @onclick="(() => Edge(0))">Line A</button>
	<button class="btn btn-primary" @onclick="(() => Edge(10))">Line B</button>
	<button class="btn btn-primary" @onclick="(() => Edge(2))">Line C</button>
	<button class="btn btn-primary" @onclick="(() => Edge(4))">Line D</button>
	@*<button class="btn btn-primary" @onclick="(() => Edge(1))">Line B</button>*@
	@*<button class="btn btn-primary" @onclick="(() => Edge(3))">Line </button>*@
	<br />

	<button class="btn btn-primary" @onclick="Grayscale">Grayscale</button>
	<button class="btn btn-primary" @onclick="GaussianBlur">GaussianBlur</button>
	<button class="btn btn-primary" @onclick="OilPaint">Oil Paint</button>
	<br />

	<button class="btn btn-primary" @onclick="Undo">Undo</button>
	<button class="btn btn-primary" @onclick="Redo">Redo</button>
	<button class="btn btn-primary" @onclick="Reset">Reset</button>
	<button class="btn btn-primary" @onclick="Flatten">Flatten</button>
	<br />

	<div class="slidecontainer">
		@*using javascript function to change input values*@


		Contrast<br />
		<input type="range" class="slider" id="slider_Contrast" min="-1" max="1" step="0.0025" value="0" @onchange="Onchange_Slider_Contrast">
		<input type="text" id="text_Contrast" style="width: 100px;" value="0" @onchange="Onchange_Slider_Contrast">
		<br />

		Brightness<br />
		<input type="range" class="slider" id="slider_Brightness" min="-255" max="255" value="0" @onchange="Onchange_Slider_Brightness">
		<input type="text" id="text_Brightness" style="width: 100px;" value="0" @onchange="Onchange_Slider_Brightness">
		<br />

		Opacity<br />
		<input type="range" class="slider" id="slider_Opacity" min="-255" max="255" value="0" @onchange="Onchange_Slider_Opacity">
		<input type="text" id="text_Opacity" style="width: 100px;" value="0" @onchange="Onchange_Slider_Opacity">
		<br />


		Red<br />
		<input type="range" class="slider" id="slider_Red" min="-255" max="255" value="0" @onchange="Onchange_Slider_Red">
		<input type="text" id="text_Red" style="width: 100px;" value="0" @onchange="Onchange_Slider_Red">
		<br />

		Green<br />
		<input type="range" class="slider" id="slider_Green" min="-255" max="255" value="0" @onchange="Onchange_Slider_Green">
		<input type="text" id="text_Green" style="width: 100px;" value="0" @onchange="Onchange_Slider_Green">
		<br />

		Blue<br />
		<input type="range" class="slider" id="slider_Blue" min="-255" max="255" value="0" @onchange="Onchange_Slider_Blue">
		<input type="text" id="text_Blue" style="width: 100px;" value="0" @onchange="Onchange_Slider_Blue">
		<br />

	</div>
</div>




@if (displayImage == true)
{
	<p>
		<div>
			<img class="image_display"
				 src="@imgSharp.ToBase64String(IIF1)" />
		</div>
	</p>
}
<p>
	<figcaption>Notes:</figcaption>
	<ul>
		<li>If using line filters, use images with high resolution and minimal background for best results.</li>
		<li>Loading/editing a large image may take >45 seconds due to web app performance limitations.</li>
		<li>No data gets collected on this site.</li>
	</ul>
</p>


@*###########################################################*@
@*###########################################################*@
@*###########################################################*@
@*###########################################################*@
@*###########################################################*@
@*###########################################################*@
@*###########################################################*@
@*###########################################################*@
@*###########################################################*@
@*###########################################################*@
@*###########################################################*@
@*###########################################################*@
@*###########################################################*@
@*###########################################################*@
@*###########################################################*@
@*###########################################################*@


@code {

	void InformationLog()
	{
		infolog1 = "imgSharplist_undo.Count: " + imgSharplist_undo.Count.ToString();
		infolog2 = "imgSharplist_redo.Count: " + imgSharplist_redo.Count.ToString();
		Debug.WriteLine(infolog1);
		Debug.WriteLine(infolog2);
		Debug.WriteLine(brushsize);
	}

	//incremental filters - BEG
	//incremental filters
	//incremental filters
	//incremental filters

	void ApplyBaseImageAndIncrementalFiltersToCurrentImage()
	{
		////3 edit image
		////3 edit image
		////make imgSharp = imgSharp_original2 (base image) prior to adding incremental filters
		for (int y = 0; y < imgSharp.Height; y++)
		{
			Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
			for (int x = 0; x < imgSharp.Width; x++)
			{
				pixelRowSpan[x] = new Rgba32(imgSharp_original2[x, y].R, imgSharp_original2[x, y].G, imgSharp_original2[x, y].B, imgSharp_original2[x, y].A);
			}
		}
		////adding incremental filters - try to make the codes shorter
		foreach (var a in DictV)
		{
			if (a.Key == "ContrastV")
			{
				Contrast(a.Value); //0.0-3.0
			}
			if (a.Key == "BrightnessV")
			{
				Brightness((int)a.Value);
			}
			if (a.Key == "OpacityV")
			{
				Opacity((int)a.Value);
			}
			if (a.Key == "RedV")
			{
				Red((int)a.Value);
			}
			if (a.Key == "GreenV")
			{
				Green((int)a.Value);
			}
			if (a.Key == "BlueV")
			{
				Blue((int)a.Value);
			}
		}
		//3 edit image
		//3 edit image
	}

	//pixel manipulation way 2 //(storing variable)
	public void Contrast(double input_value)
	{
		if (displayImage == true)
		{
			input_value += 1; //adjust to neutral value (appears 0 to users, but uses 1 as neutral multiplication value)

			for (int y = 0; y < imgSharp.Height; y++)
			{
				Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
				for (int x = 0; x < imgSharp.Width; x++)
				{
					double brightness_adjustment = (1 - input_value) * 128; //if contrast higher, then lower brightness. vice versa.
					double red = input_value * imgSharp[x, y].R + brightness_adjustment;
					double green = input_value * imgSharp[x, y].G + brightness_adjustment;
					double blue = input_value * imgSharp[x, y].B + brightness_adjustment;

					if (red > 255) { red = 255; }
					else if (red < 0) { red = 0; }
					if (green > 255) { green = 255; }
					else if (green < 0) { green = 0; }
					if (blue > 255) { blue = 255; }
					else if (blue < 0) { blue = 0; }

					byte red2 = (byte)red;
					byte green2 = (byte)green;
					byte blue2 = (byte)blue;

					pixelRowSpan[x] = new Rgba32(red2, green2, blue2, imgSharp[x, y].A);
				}
			}
			//TO DO
		}
	}

	//pixel manipulation way 2 //(storing variable)
	public void Brightness(int input_value)
	{
		if (displayImage == true)
		{
			for (int y = 0; y < imgSharp.Height; y++)
			{
				Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
				for (int x = 0; x < imgSharp.Width; x++)
				{
					int red = imgSharp[x, y].R + input_value;
					int green = imgSharp[x, y].G + input_value;
					int blue = imgSharp[x, y].B + input_value;

					if (red > 255) { red = 255; }
					else if (red < 0) { red = 0; }
					if (green > 255) { green = 255; }
					else if (green < 0) { green = 0; }
					if (blue > 255) { blue = 255; }
					else if (blue < 0) { blue = 0; }

					byte red2 = (byte)red;
					byte green2 = (byte)green;
					byte blue2 = (byte)blue;

					pixelRowSpan[x] = new Rgba32(red2, green2, blue2, imgSharp[x, y].A);
				}
			}

			//TO DO
		}
	}

	//pixel manipulation way 2 (using stored variable (byte))
	void Opacity(int input_value)
	{
		if (displayImage == true)
		{
			for (int y = 0; y < imgSharp.Height; y++)
			{
				Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
				for (int x = 0; x < imgSharp.Width; x++)
				{
					int alpha = imgSharp[x, y].A + input_value;

					if (alpha > 255) { alpha = 255; }
					else if (alpha < 0) { alpha = 0; }

					byte alpha2 = (byte)alpha;

					pixelRowSpan[x] = new Rgba32(imgSharp[x, y].R, imgSharp[x, y].G, imgSharp[x, y].B, alpha2);
				}
			}
		}
	}

	//pixel manipulation way 2 (using stored variable (byte))
	void Red(int input_value)
	{
		if (displayImage == true)
		{
			for (int y = 0; y < imgSharp.Height; y++)
			{
				Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
				for (int x = 0; x < imgSharp.Width; x++)
				{
					int red = imgSharp[x, y].R + input_value;
					int green = imgSharp[x, y].G;
					int blue = imgSharp[x, y].B;

					if (red > 255) { red = 255; }
					else if (red < 0) { red = 0; }
					if (green > 255) { green = 255; }
					else if (green < 0) { green = 0; }
					if (blue > 255) { blue = 255; }
					else if (blue < 0) { blue = 0; }

					byte red2 = (byte)red;
					byte green2 = (byte)green;
					byte blue2 = (byte)blue;

					pixelRowSpan[x] = new Rgba32(red2, green2, blue2, imgSharp[x, y].A);
				}
			}
			//TO DO
		}
	}

	//pixel manipulation way 2 (using stored variable (byte))
	void Green(int input_value)
	{
		if (displayImage == true)
		{
			for (int y = 0; y < imgSharp.Height; y++)
			{
				Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
				for (int x = 0; x < imgSharp.Width; x++)
				{
					int red = imgSharp[x, y].R;
					int green = imgSharp[x, y].G + input_value;
					int blue = imgSharp[x, y].B;

					if (red > 255) { red = 255; }
					else if (red < 0) { red = 0; }
					if (green > 255) { green = 255; }
					else if (green < 0) { green = 0; }
					if (blue > 255) { blue = 255; }
					else if (blue < 0) { blue = 0; }

					byte red2 = (byte)red;
					byte green2 = (byte)green;
					byte blue2 = (byte)blue;

					pixelRowSpan[x] = new Rgba32(red2, green2, blue2, imgSharp[x, y].A);
				}
			}
			//TO DO
		}
	}

	//pixel manipulation way 2 (using stored variable (byte))
	void Blue(int input_value)
	{
		if (displayImage == true)
		{
			for (int y = 0; y < imgSharp.Height; y++)
			{
				Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
				for (int x = 0; x < imgSharp.Width; x++)
				{
					int red = imgSharp[x, y].R;
					int green = imgSharp[x, y].G;
					int blue = imgSharp[x, y].B + input_value;

					if (red > 255) { red = 255; }
					else if (red < 0) { red = 0; }
					if (green > 255) { green = 255; }
					else if (green < 0) { green = 0; }
					if (blue > 255) { blue = 255; }
					else if (blue < 0) { blue = 0; }

					byte red2 = (byte)red;
					byte green2 = (byte)green;
					byte blue2 = (byte)blue;

					pixelRowSpan[x] = new Rgba32(red2, green2, blue2, imgSharp[x, y].A);
				}
			}
			//TO DO
		}
	}


	void Onchange_Slider_Contrast(ChangeEventArgs e)
	{
		ClearRedo();                   //0.8
		is_FilterIncremental = true;   //0.9
		SaveAttributesToUndoLists();   //1-1.4

		////2
		double input_value = double.Parse(e.Value.ToString());
		DictV["IncV"] = 1;
		DictV["ContrastV"] = input_value;

		////3 edit image
		ApplyBaseImageAndIncrementalFiltersToCurrentImage();

		//update slider "knob" and associated text value
		JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Contrast", input_value);
	}
	void Onchange_Slider_Brightness(ChangeEventArgs e)
	{
		ClearRedo();                   //0.8
		is_FilterIncremental = true;   //0.9
		SaveAttributesToUndoLists();   //1-1.4

		////2
		int input_value = int.Parse(e.Value.ToString());
		DictV["IncV"] = 1;
		DictV["BrightnessV"] = input_value;

		////3 edit image
		ApplyBaseImageAndIncrementalFiltersToCurrentImage();

		//update slider "knob" and associated text value
		JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Brightness", input_value);
	}
	void Onchange_Slider_Opacity(ChangeEventArgs e)
	{
		ClearRedo();                   //0.8
		is_FilterIncremental = true;   //0.9
		SaveAttributesToUndoLists();   //1-1.4

		////2
		int input_value = int.Parse(e.Value.ToString());
		DictV["IncV"] = 1;
		DictV["OpacityV"] = input_value;

		////3 edit image
		ApplyBaseImageAndIncrementalFiltersToCurrentImage();

		//update slider "knob" and associated text value
		JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Opacity", input_value);

	}
	void Onchange_Slider_Red(ChangeEventArgs e)
	{
		ClearRedo();                   //0.8
		is_FilterIncremental = true;   //0.9
		SaveAttributesToUndoLists();   //1-1.4

		////2
		int input_value = int.Parse(e.Value.ToString());
		DictV["IncV"] = 1;
		DictV["RedV"] = input_value;

		////3 edit image
		ApplyBaseImageAndIncrementalFiltersToCurrentImage();

		////update slider "knob" and associated text value
		JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Red", input_value);
	}

	void Onchange_Slider_Green(ChangeEventArgs e)
	{
		ClearRedo();                   //0.8
		is_FilterIncremental = true;   //0.9
		SaveAttributesToUndoLists();   //1-1.4

		////2
		int input_value = int.Parse(e.Value.ToString());
		DictV["IncV"] = 1;
		DictV["GreenV"] = input_value;

		////3 edit image
		ApplyBaseImageAndIncrementalFiltersToCurrentImage();

		////update slider "knob" and associated text value
		JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Green", input_value);
	}

	void Onchange_Slider_Blue(ChangeEventArgs e)
	{
		ClearRedo();                   //0.8
		is_FilterIncremental = true;   //0.9
		SaveAttributesToUndoLists();   //1-1.4

		////2
		int input_value = int.Parse(e.Value.ToString());
		DictV["IncV"] = 1;
		DictV["BlueV"] = input_value;

		////3 edit image
		ApplyBaseImageAndIncrementalFiltersToCurrentImage();

		////update slider "knob" and associated text value
		JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Blue", input_value);
	}

	//incremental filters - END
	//incremental filters
	//incremental filters
	//incremental filters



	void Flatten() //looks good
	{
		ClearRedo();                   //0.8
		is_FilterIncremental = true;   //0.9 //might be true to avoid playing flatten() in infinite loop
		SaveAttributesToUndoLists();   //1-1.4

		////2 reset all incremental filter attributes to 0
		foreach (var a in DictV)
		{
			DictV[a.Key] = 0;
		}



		////2.5 (imgSharp_original2 = imgSharp)
		for (int y = 0; y < imgSharp_original2.Height; y++)
		{
			for (int x = 0; x < imgSharp_original2.Width; x++)
			{
				imgSharp_original2[x, y] = new Rgba32(imgSharp[x, y].R, imgSharp[x, y].G, imgSharp[x, y].B, imgSharp[x, y].A);
			}
		}

		////3 no action needed (imgSharp = imgSharp_original2

		////way1 - call javascript function invokevoidasync, reset slider position and text value
		JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Contrast");
		JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Brightness");
		JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Opacity");
		JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Red");
		JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Green");
		JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Blue");
	}

	void Flatten_nosavingtoundo() //looks good
	{

		////2 reset all incremental filter attributes to 0
		foreach (var a in DictV)
		{
			DictV[a.Key] = 0;
		}

		////2.5 (imgSharp_original2 = imgSharp)
		for (int y = 0; y < imgSharp_original2.Height; y++)
		{
			for (int x = 0; x < imgSharp_original2.Width; x++)
			{
				imgSharp_original2[x, y] = new Rgba32(imgSharp[x, y].R, imgSharp[x, y].G, imgSharp[x, y].B, imgSharp[x, y].A);
			}
		}

		////3 no action needed (imgSharp = imgSharp_original2

		////way1 - call javascript function invokevoidasync, reset slider position and text value
		JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Contrast");
		JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Brightness");
		JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Opacity");
		JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Red");
		JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Green");
		JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Blue");
	}





	void Filter1()
	{
		ClearRedo();                   //0.8
		is_FilterIncremental = false;  //0.9
		SaveAttributesToUndoLists();   //1-1.4

		////2 (reset incremental filter attributes when user uses non-incremental filter)
		foreach (var a in DictV)
		{
			DictV[a.Key] = 0;
		}

		////3
		imgSharp.Mutate(ctx => ctx.Lomograph());
		//imgSharp.Mutate(ctx => ctx.Quantize());
		//imgSharp.Mutate(ctx => ctx.HistogramEqualization());

		////4 affix
		Flatten_nosavingtoundo();
	}

	public void Filter2()
	{
		ClearRedo();                   //0.8
		is_FilterIncremental = false;  //0.9
		SaveAttributesToUndoLists();   //1-1.4

		////2 (reset incremental filter attributes when user uses non-incremental filter)
		foreach (var a in DictV)
		{
			DictV[a.Key] = 0;
		}

		////3
		imgSharp.Mutate(ctx => ctx.HistogramEqualization());
		//imgSharp.Mutate(ctx => ctx.Quantize());
		//imgSharp.Mutate(ctx => ctx.Lomograph());

		////4 affix
		Flatten_nosavingtoundo();

	}



	//pixel manipulation way 2
	//(storing variable)
	public void OpacityUP()
	{
		if (displayImage == true)
		{
			int alpha;
			byte alpha2;

			for (int y = 0; y < imgSharp.Height; y++)
			{
				Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
				for (int x = 0; x < imgSharp.Width; x++)
				{
					alpha = imgSharp[x, y].A + 20;
					if (alpha > 255) { alpha = 255; }
					else if (alpha < 0) { alpha = 0; }
					alpha2 = (byte)alpha;

					pixelRowSpan[x] = new Rgba32(imgSharp[x, y].R, imgSharp[x, y].G, imgSharp[x, y].B, alpha2);
				}
			}
		}
	}

	//pixel manipulation way 2
	//(storing variable)
	public void OpacityDOWN()
	{
		if (displayImage == true)
		{
			int alpha;
			byte alpha2;

			for (int y = 0; y < imgSharp.Height; y++)
			{
				Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
				for (int x = 0; x < imgSharp.Width; x++)
				{
					alpha = imgSharp[x, y].A - 20;
					if (alpha > 255) { alpha = 255; }
					else if (alpha < 0) { alpha = 0; }
					alpha2 = (byte)alpha;

					pixelRowSpan[x] = new Rgba32(imgSharp[x, y].R, imgSharp[x, y].G, imgSharp[x, y].B, alpha2);
				}
			}
		}
	}


	public void GaussianBlur()
	{
		if (displayImage == true)
		{
			ClearRedo();                   //0.8
			is_FilterIncremental = false;  //0.9
			SaveAttributesToUndoLists();   //1-1.4

			////2 (reset incremental filter attributes when user uses non-incremental filter)
			foreach (var a in DictV)
			{
				DictV[a.Key] = 0;
			}

			////3
			imgSharp.Mutate(ctx => ctx.GaussianBlur(1));

			////4 affix
			Flatten_nosavingtoundo();
		}
	}




	//pixel manipulation way 1
	//(storing variable)
	//grayscale filter
	void Grayscale()
	{
		if (displayImage == true)
		{

			ClearRedo();                   //0.8
			is_FilterIncremental = false;  //0.9
			SaveAttributesToUndoLists();   //1-1.4

			//2 (reset incremental filter attributes when user uses non-incremental filter)
			foreach (var a in DictV)
			{
				DictV[a.Key] = 0;
			}

			//3 (none) dont use ApplyBaseImageAndIncrementalFiltersToCurrentImage method?
			for (int w = 0; w < imgSharp.Width; w++)
			{
				for (int h = 0; h < imgSharp.Height; h++)
				{
					int bwcolor = (imgSharp_original2[w, h].R + imgSharp_original2[w, h].G + imgSharp_original2[w, h].B) / 3;
					byte bwcolor2 = (byte)bwcolor;
					imgSharp[w, h] = new Rgba32(bwcolor2, bwcolor2, bwcolor2, imgSharp[w, h].A);
				}
			}

			//4 affix
			Flatten_nosavingtoundo();
		}
	}


	//WIP, use way 2,
	//works on small image
	void Edge(int parameter1)
	{
		if (displayImage == true)
		{
			showprocessing = true;
			ClearRedo();                   //0.8
			is_FilterIncremental = false;  //0.9
			SaveAttributesToUndoLists();   //1-1.4

			////2 (reset incremental filter attributes when user uses non-incremental filter)
			foreach (var a in DictV)
			{
				DictV[a.Key] = 0;
			}

			////3 edit

			int height = imgSharp.Height - 1;
			int width = imgSharp.Width - 1; //preivious -1

			int[,] array_gx = new int[3, 3];
			int[,] array_gy = new int[3, 3];


			//prewitt
			if (parameter1 == 10)
			{
				OilPaint();
			}

			if (parameter1 == 0 || parameter1 == 10)
			{
				//sobel
				array_gx[0, 0] = -1; array_gx[0, 1] = 0; array_gx[0, 2] = 1;
				array_gx[1, 0] = -2; array_gx[1, 1] = 0; array_gx[1, 2] = 2;
				array_gx[2, 0] = -1; array_gx[2, 1] = 0; array_gx[2, 2] = 1;
				array_gy[0, 0] = -1; array_gy[0, 1] = -2; array_gy[0, 2] = -1;
				array_gy[1, 0] = 0; array_gy[1, 1] = 0; array_gy[1, 2] = 0;
				array_gy[2, 0] = 1; array_gy[2, 1] = 2; array_gy[2, 2] = 1;
			}
			else if (parameter1 == 1 || parameter1 == 2 || parameter1 == 3)
			{
				//alternative, prewitt?, more intense
				array_gx[0, 0] = -2; array_gx[0, 1] = 0; array_gx[0, 2] = 2;
				array_gx[1, 0] = -2; array_gx[1, 1] = 0; array_gx[1, 2] = 2;
				array_gx[2, 0] = -2; array_gx[2, 1] = 0; array_gx[2, 2] = 2;
				array_gy[0, 0] = -2; array_gy[0, 1] = -2; array_gy[0, 2] = -2;
				array_gy[1, 0] = 0; array_gy[1, 1] = 0; array_gy[1, 2] = 0;
				array_gy[2, 0] = 2; array_gy[2, 1] = 2; array_gy[2, 2] = 2;
			}
			else if (parameter1 == 4)
			{
				//alternative, prewitt?, more intense
				array_gx[0, 0] = 5; array_gx[0, 1] = 5; array_gx[0, 2] = 5;
				array_gx[1, 0] = -3; array_gx[1, 1] = 0; array_gx[1, 2] = -3;
				array_gx[2, 0] = -3; array_gx[2, 1] = -3; array_gx[2, 2] = -3;
				array_gy[0, 0] = 5; array_gy[0, 1] = -3; array_gy[0, 2] = -3;
				array_gy[1, 0] = 5; array_gy[1, 1] = 0; array_gy[1, 2] = -3;
				array_gy[2, 0] = 5; array_gy[2, 1] = -3; array_gy[2, 2] = -3;
			}

			//init
			int val_Alpha = 0;
			byte val_Alpha2 = 0;

			int val_Blue = 0;
			int val_Green = 0;
			int val_Red = 0;

			int Gx_sum_Blue = 0;
			int Gx_sum_Green = 0;
			int Gx_sum_Red = 0;

			int Gy_sum_Blue = 0;
			int Gy_sum_Green = 0;
			int Gy_sum_Red = 0;

			int Gxy_sum_final_Blue = 0;
			int Gxy_sum_final_Green = 0;
			int Gxy_sum_final_Red = 0;

			//int logprint_sum1 = 0;


			for (int y = 0; y <= height; y++)
			{
				if (y == 0) { continue; }
				if (y == height - 1) { continue; }
				if (y == height) { continue; }
				Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
				for (int x = 0; x <= width; x++)
				{
					if (x == 0) { continue; }
					if (x == width - 1) { continue; }
					if (x == width) { continue; }

					Gx_sum_Blue = 0;
					Gx_sum_Green = 0;
					Gx_sum_Red = 0;

					Gy_sum_Blue = 0;
					Gy_sum_Green = 0;
					Gy_sum_Red = 0;

					Gxy_sum_final_Blue = 0;
					Gxy_sum_final_Green = 0;
					Gxy_sum_final_Red = 0;

					//// finding Gx and Gy
					//// finding Gx and Gy
					for (int r = 0; r < 3; r++)
					{
						for (int c = 0; c < 3; c++)
						{
							//fix this part, so it can work on any image on BS1 app
							if (((y + (r - 1) >= 0) && (x + (c - 1) >= 0)) && ((y + (r - 1) <= height) && (x + (c - 1) <= width)))
							{
								int he = y + (r - 1);
								int we = x + (c - 1);

								//val_Blue = imgSharp[he, we].B;
								//val_Green = imgSharp[he, we].G;
								//val_Red = imgSharp[he, we].R;

								val_Blue = imgSharp_original2[we, he].B;
								val_Green = imgSharp_original2[we, he].G;
								val_Red = imgSharp_original2[we, he].R;
							}
							//fix this part, so it can work on any image on BS1 app


							// if outside the border (row)
							if ((y + (r - 1) < 0) || (y + (r - 1) > (height - 1)))
							{
								val_Blue = 0;
								val_Green = 0;
								val_Red = 0;
								//logprint_sum1++; //2400
							}

							// if outside the border (column)
							// 400
							else if ((x + (c - 1) < 0) || (x + (c - 1) > (width - 1)))
							{
								val_Blue = 0;
								val_Green = 0;
								val_Red = 0;
								//logprint_sum1++; //3290
							}

							Gx_sum_Blue += val_Blue * array_gx[r, c];
							Gx_sum_Green += val_Green * array_gx[r, c];
							Gx_sum_Red += val_Red * array_gx[r, c];

							Gy_sum_Blue += val_Blue * array_gy[r, c];
							Gy_sum_Green += val_Green * array_gy[r, c];
							Gy_sum_Red += val_Red * array_gy[r, c];

						}
					}
					//// finding Gx and Gy
					//// finding Gx and Gy



					//store alpha for desired modification
					val_Alpha = imgSharp[x, y].A;

					Gxy_sum_final_Blue = (int)Math.Sqrt(((Math.Pow(Gx_sum_Blue, 2)) + (Math.Pow(Gy_sum_Blue, 2))));
					Gxy_sum_final_Green = (int)(Math.Sqrt((Math.Pow(Gx_sum_Green, 2)) + (Math.Pow(Gy_sum_Green, 2))));
					Gxy_sum_final_Red = (int)Math.Sqrt(((Math.Pow(Gx_sum_Red, 2)) + (Math.Pow(Gy_sum_Red, 2))));


					////modification BEG
					////modification BEG


					//make weak white lines stronger (applies to black background/white line, non-invert) //way 2

					double m1 = 1.33; //0.5 darker, 1 normal, 2 whiter //BUTTON/SLIDER HERE!!!!
					if (parameter1 == 4 || parameter1 == 1) { m1 = 1; }
					if (Gxy_sum_final_Blue >= 45 && Gxy_sum_final_Blue <= 160) { Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue * m1); }
					if (Gxy_sum_final_Green >= 45 && Gxy_sum_final_Green <= 160) { Gxy_sum_final_Green = (int)(Gxy_sum_final_Green * m1); }
					if (Gxy_sum_final_Red >= 45 && Gxy_sum_final_Red <= 160) { Gxy_sum_final_Red = (int)(Gxy_sum_final_Red * m1); }
					//make strong white lines weaker (applies to black background/white line, non-invert) //way 2
					double m2 = 0.90; //0.90 //BUTTON/SLIDER HERE!!!
					if (Gxy_sum_final_Blue >= 180 && Gxy_sum_final_Blue <= 230) { Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue * m2); }
					if (Gxy_sum_final_Green >= 180 && Gxy_sum_final_Green <= 230) { Gxy_sum_final_Green = (int)(Gxy_sum_final_Green * m2); }
					if (Gxy_sum_final_Red >= 180 && Gxy_sum_final_Red <= 230) { Gxy_sum_final_Red = (int)(Gxy_sum_final_Red * m2); }


					//ui idea
					//idea: set a range (ex: 80-200) for weak white lines to get whiter
					//idea: set another range (ex: 200-255) for strong white lines to get darker
					////modification END
					////modification END








					//////custom color background
					//int cutoff = 15; //should try make a slider ouit of this //IDEA1 //make alpha=0 background //30, 45, 60, 75
					//if (parameter1 == 1) { cutoff = 60; } //30, 45, 60, 75// previously 60
					//if (Gxy_sum_final_Blue <= cutoff && Gxy_sum_final_Green <= cutoff && Gxy_sum_final_Red <= cutoff)
					//{

					//	Gxy_sum_final_Blue = 0;
					//	Gxy_sum_final_Green = 0;
					//	Gxy_sum_final_Red = 0;
					//}
					//else
					//{
					//	//if (Gxy_sum_final_Blue < cutoff) { Gxy_sum_final_Blue = cutoff; }
					//	//if (Gxy_sum_final_Green < cutoff) { Gxy_sum_final_Green = cutoff; }
					//	//if (Gxy_sum_final_Red < cutoff) { Gxy_sum_final_Red = cutoff; }
					//	//Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue * 1.33);
					//	//Gxy_sum_final_Green = (int)(Gxy_sum_final_Green * 1.33);
					//	//Gxy_sum_final_Red = (int)(Gxy_sum_final_Red * 1.33);
					//}
					//OR..
					//////..transparant (before invert)
					//int cutoff = 128; //should try make a slider ouit of this //IDEA1 //make alpha=0 background //180 FOR TRANSPARRENCY
					//if (Gxy_sum_final_Blue <= cutoff && Gxy_sum_final_Green <= cutoff && Gxy_sum_final_Red <= cutoff)
					//{
					//    val_Alpha = 0;
					//}
					//else
					//{
					//    //if (Gxy_sum_final_Blue < cutoff) { Gxy_sum_final_Blue = cutoff; }
					//    //if (Gxy_sum_final_Green < cutoff) { Gxy_sum_final_Green = cutoff; }
					//    //if (Gxy_sum_final_Red < cutoff) { Gxy_sum_final_Red = cutoff; }
					//    Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue * 1/0.20); //should make sliders out of these //IDEA2 ex: 100% = 1, 200% = 2
					//    Gxy_sum_final_Green = (int)(Gxy_sum_final_Green * 1/0.20);
					//    Gxy_sum_final_Red = (int)(Gxy_sum_final_Red * 1/0.20);
					//}


					//keep ARGB within 0-255
					if (Gxy_sum_final_Blue > 255) { Gxy_sum_final_Blue = 255; }
					if (Gxy_sum_final_Green > 255) { Gxy_sum_final_Green = 255; }
					if (Gxy_sum_final_Red > 255) { Gxy_sum_final_Red = 255; }
					if (Gxy_sum_final_Blue < 0) { Gxy_sum_final_Blue = 0; }
					if (Gxy_sum_final_Green < 0) { Gxy_sum_final_Green = 0; }
					if (Gxy_sum_final_Red < 0) { Gxy_sum_final_Red = 0; }


					//modification BEG
					//modification BEG
					//INVERT
					Gxy_sum_final_Red = 255 - Gxy_sum_final_Red;
					Gxy_sum_final_Green = 255 - Gxy_sum_final_Green;
					Gxy_sum_final_Blue = 255 - Gxy_sum_final_Blue;



					//////////..transparant (after invert)
					int cutoff = 225; //should try make a slider ouit of this //IDEA1 //make alpha=0 background //180 FOR TRANSPARRENCY
					if (Gxy_sum_final_Blue >= cutoff && Gxy_sum_final_Blue >= cutoff && Gxy_sum_final_Blue >= cutoff)
					{
						val_Alpha = 0;


					}
					else
					{
						//Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue); //should make sliders out of these //IDEA2 ex: 100% = 1, 200% = 2
						//Gxy_sum_final_Green = (int)(Gxy_sum_final_Green);
						//Gxy_sum_final_Red = (int)(Gxy_sum_final_Red);
						//if (Gxy_sum_final_Blue > cutoff) { Gxy_sum_final_Blue = cutoff; }
						//if (Gxy_sum_final_Green > cutoff) { Gxy_sum_final_Green = cutoff; }
						//if (Gxy_sum_final_Red > cutoff) { Gxy_sum_final_Red = cutoff; }
					}
					if (Gxy_sum_final_Blue < cutoff - 25) { Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue * 0.9); }
					if (Gxy_sum_final_Green < cutoff - 25) { Gxy_sum_final_Green = (int)(Gxy_sum_final_Green * 0.9); }
					if (Gxy_sum_final_Red < cutoff - 25) { Gxy_sum_final_Red = (int)(Gxy_sum_final_Red * 0.9); }
					if (Gxy_sum_final_Blue < 128) { Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue * 0.7); }
					if (Gxy_sum_final_Green < 128) { Gxy_sum_final_Green = (int)(Gxy_sum_final_Green * 0.7); }
					if (Gxy_sum_final_Red < 128) { Gxy_sum_final_Red = (int)(Gxy_sum_final_Red * 0.7); }
					if (Gxy_sum_final_Blue < 64) { Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue * 0.5); }
					if (Gxy_sum_final_Green < 64) { Gxy_sum_final_Green = (int)(Gxy_sum_final_Green * 0.5); }
					if (Gxy_sum_final_Red < 64) { Gxy_sum_final_Red = (int)(Gxy_sum_final_Red * 0.5); }


					//No BW and/or shade way 0

					if (parameter1 == 1 || parameter1 == 0 || parameter1 == 10)
					{
						////Make BW only way 1
						int bwcolor = (Gxy_sum_final_Blue + Gxy_sum_final_Green + Gxy_sum_final_Red) / 3;
						Gxy_sum_final_Blue = bwcolor;
						Gxy_sum_final_Green = bwcolor;
						Gxy_sum_final_Red = bwcolor;
					}

					//
					else if (parameter1 == 2)
					{
						//Make BW + shade way 2
						int bwcolor = (Gxy_sum_final_Blue + Gxy_sum_final_Green + Gxy_sum_final_Red) / 3;
						int bwcolor2 = (int)(((imgSharp_original2[x, y].R + imgSharp_original2[x, y].G + imgSharp_original2[x, y].B) / 3) * 1.0);
						//if (bwcolor2 > 255) { bwcolor = 255; }
						//if (bwcolor2 < 0) { bwcolor = 0; }
						//add shade
						if (bwcolor2 <= bwcolor && bwcolor2 <= 230)
						{
							Gxy_sum_final_Blue = bwcolor2;
							Gxy_sum_final_Green = bwcolor2;
							Gxy_sum_final_Red = bwcolor2;
						}
						else
						{
							Gxy_sum_final_Blue = bwcolor;
							Gxy_sum_final_Green = bwcolor;
							Gxy_sum_final_Red = bwcolor;
						}
					}


					else if (parameter1 == 3)
					{
						////Make shade way 3
						//double adj1 = 1.3;
						//double adj2 = 0; //no needed, probably just use white line whitener, dark spot darker block-of-code from earlier
						//int bwcolor = (int)(Gxy_sum_final_Blue + Gxy_sum_final_Green + Gxy_sum_final_Red) / 3;
						//int bwcolor2 = (int)(((imgSharp_original1[x, y].R + imgSharp_original1[x, y].G + imgSharp_original1[x, y].B) / 3) * adj1); //0.60 to cheat
						//if (bwcolor2 > 255) { bwcolor = 255; }
						//if (bwcolor2 < 0) { bwcolor = 0; }
						//if (bwcolor2 <= bwcolor)
						//{
						//    Gxy_sum_final_Blue = (int)(imgSharp_original1[x, y].B * adj1);
						//    Gxy_sum_final_Green = (int)(imgSharp_original1[x, y].G * adj1);
						//    Gxy_sum_final_Red = (int)(imgSharp_original1[x, y].R * adj1);
						//}
						//else
						//{
						//    Gxy_sum_final_Blue = (int)(bwcolor - adj2);
						//    Gxy_sum_final_Green = (int)(bwcolor - adj2);
						//    Gxy_sum_final_Red = (int)(bwcolor - adj2);
						//}

						////Make shade way 3.2
						int bwcolor = (Gxy_sum_final_Blue + Gxy_sum_final_Green + Gxy_sum_final_Red) / 3;
						int bwcolor2 = (int)(((imgSharp_original2[x, y].R + imgSharp_original2[x, y].G + imgSharp_original2[x, y].B) / 3) * 1.0);
						//if (bwcolor2 > 255) { bwcolor = 255; }
						//if (bwcolor2 < 0) { bwcolor = 0; }
						//add shade
						if (bwcolor2 <= bwcolor && bwcolor2 <= 255)
						{
							Gxy_sum_final_Blue = imgSharp_original2[x, y].B;
							Gxy_sum_final_Green = imgSharp_original2[x, y].G;
							Gxy_sum_final_Red = imgSharp_original2[x, y].R;
						}
						else
						{
							Gxy_sum_final_Blue = bwcolor;
							Gxy_sum_final_Green = bwcolor;
							Gxy_sum_final_Red = bwcolor;
						}
					}

					else if (parameter1 == 4)
					{
						//ray effect way 4 = from way 1, grayscale with color lines
						////Make BW
						int bwcolor = (Gxy_sum_final_Blue + Gxy_sum_final_Green + Gxy_sum_final_Red) / 3;
						Gxy_sum_final_Blue = bwcolor;
						Gxy_sum_final_Green = bwcolor;
						Gxy_sum_final_Red = bwcolor;

						int bwcolor2 = (((imgSharp_original2[x, y].R + imgSharp_original2[x, y].G + imgSharp_original2[x, y].B) / 3));
						//add shade
						if (bwcolor2 <= bwcolor)
						{
							Gxy_sum_final_Blue = bwcolor2;


						}
						Gxy_sum_final_Green = bwcolor2;
						Gxy_sum_final_Red = bwcolor2;
					}
					//modification END
					//modification END


					//keep ARGB within 0-255
					if (Gxy_sum_final_Blue > 255) { Gxy_sum_final_Blue = 255; }
					if (Gxy_sum_final_Green > 255) { Gxy_sum_final_Green = 255; }
					if (Gxy_sum_final_Red > 255) { Gxy_sum_final_Red = 255; }
					if (Gxy_sum_final_Blue < 0) { Gxy_sum_final_Blue = 0; }
					if (Gxy_sum_final_Green < 0) { Gxy_sum_final_Green = 0; }
					if (Gxy_sum_final_Red < 0) { Gxy_sum_final_Red = 0; }


					//recreate with byte variables cuz ImageSharp
					byte Gxy_sum_final_Red2 = (byte)Gxy_sum_final_Red;
					byte Gxy_sum_final_Green2 = (byte)Gxy_sum_final_Green;
					byte Gxy_sum_final_Blue2 = (byte)Gxy_sum_final_Blue;
					val_Alpha2 = (byte)val_Alpha;

					pixelRowSpan[x] = new Rgba32(Gxy_sum_final_Red2, Gxy_sum_final_Green2, Gxy_sum_final_Blue2, val_Alpha2);
				}
			}
			//4 affix
			Flatten_nosavingtoundo();

			showprocessing = false;
		}
	}


	void OilPaint()
	{
		ClearRedo();                   //0.8
		is_FilterIncremental = false;  //0.9
		SaveAttributesToUndoLists();   //1-1.4

		////2 (reset incremental filter attributes when user uses non-incremental filter)
		foreach (var a in DictV)
		{
			DictV[a.Key] = 0;
		}

		////3
		brushsize = (imgSharp.Width * imgSharp.Height) * .000004;
		if (brushsize <= 6) { brushsize = 6; }
		imgSharp.Mutate(x => x.OilPaint(20, (int)brushsize));
		////public static IImageProcessingContext OilPaint(this IImageProcessingContext source, int levels, int brushSize);
		////4 affix
		Flatten_nosavingtoundo(); //no savetoundo


	}




	void Reset()
	{
		if (displayImage == true)
		{
			ClearRedo();                   //0.8
			is_FilterIncremental = false;  //0.
										   //SaveAttributesToUndoLists();   //1-1.4 //need to not use flatten in this reset

			////1
			////saving imgSharp_original2 to imgSharplist_undo list:
			Image<Rgba32> imgSharp_temporary = new Image<Rgba32>(imgSharp.Width, imgSharp.Height);
			for (int y = 0; y < imgSharp_temporary.Height; y++)
			{
				//Span<Rgba32> pixelRowSpan = imgSharp_temporary.GetPixelRowSpan(y);
				for (int x = 0; x < imgSharp_temporary.Width; x++)
				{
					imgSharp_temporary[x, y] = new Rgba32(imgSharp_original2[x, y].R, imgSharp_original2[x, y].G, imgSharp_original2[x, y].B, imgSharp_original2[x, y].A);
				}
			}
			imgSharplist_undo.Add(imgSharp_temporary);

			////1.2
			////saving incremental filter attributes to undo lists
			IncV_undo.Add(DictV["IncV"]);
			ContrastV_undo.Add(DictV["ContrastV"]);
			BrightnessV_undo.Add(DictV["BrightnessV"]);
			OpacityV_undo.Add(DictV["OpacityV"]);
			RedV_undo.Add(DictV["RedV"]);
			GreenV_undo.Add(DictV["GreenV"]);
			BlueV_undo.Add(DictV["BlueV"]);

			////1.3 (limit undo lists' count to num_limit) (unique code block)
			int num_limit = 3;
			if (imgSharplist_undo.Count > num_limit) { imgSharplist_undo.RemoveAt(0); }
			if (IncV_undo.Count > num_limit) { IncV_undo.RemoveAt(0); }
			if (ContrastV_undo.Count > num_limit) { ContrastV_undo.RemoveAt(0); }
			if (BrightnessV_undo.Count > num_limit) { BrightnessV_undo.RemoveAt(0); }
			if (OpacityV_undo.Count > num_limit) { OpacityV_undo.RemoveAt(0); }
			if (RedV_undo.Count > num_limit) { RedV_undo.RemoveAt(0); }
			if (GreenV_undo.Count > num_limit) { GreenV_undo.RemoveAt(0); }
			if (BlueV_undo.Count > num_limit) { BlueV_undo.RemoveAt(0); }


			////2 (reset incremental filter attributes when user uses non-incremental filter)
			foreach (var a in DictV)
			{
				DictV[a.Key] = 0;
			}

			////3
			for (int y = 0; y < imgSharp.Height; y++)
			{
				Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
				Span<Rgba32> pixelRowSpan2 = imgSharp_original2.GetPixelRowSpan(y);
				for (int x = 0; x < imgSharp.Width; x++)
				{
					pixelRowSpan[x] = new Rgba32(imgSharp_original1[x, y].R, imgSharp_original1[x, y].G, imgSharp_original1[x, y].B, imgSharp_original1[x, y].A);
					pixelRowSpan2[x] = new Rgba32(imgSharp_original1[x, y].R, imgSharp_original1[x, y].G, imgSharp_original1[x, y].B, imgSharp_original1[x, y].A);
				}
			}

			//4 affix
			Flatten_nosavingtoundo();

			JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Contrast");
			JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Brightness");
			JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Opacity");
			JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Red");
			JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Green");
			JS.InvokeVoidAsync("JS_resetsliderpositionandtextvalue_Blue");
			//foreach (var a in DictV)
			//{
			//	DictV[a.Key] = 0;
			//}
		}
	}


	void SaveAttributesToUndoLists() //1-1.4
	{
		////1
		////saving imgSharp_original2 to imgSharplist_undo list:
		Image<Rgba32> imgSharp_temporary = new Image<Rgba32>(imgSharp.Width, imgSharp.Height);
		for (int y = 0; y < imgSharp_temporary.Height; y++)
		{
			//Span<Rgba32> pixelRowSpan = imgSharp_temporary.GetPixelRowSpan(y);
			for (int x = 0; x < imgSharp_temporary.Width; x++)
			{
				imgSharp_temporary[x, y] = new Rgba32(imgSharp_original2[x, y].R, imgSharp_original2[x, y].G, imgSharp_original2[x, y].B, imgSharp_original2[x, y].A);
			}
		}
		imgSharplist_undo.Add(imgSharp_temporary);

		////1.2
		////saving incremental filter attributes to undo lists
		IncV_undo.Add(DictV["IncV"]);
		ContrastV_undo.Add(DictV["ContrastV"]);
		BrightnessV_undo.Add(DictV["BrightnessV"]);
		OpacityV_undo.Add(DictV["OpacityV"]);
		RedV_undo.Add(DictV["RedV"]);
		GreenV_undo.Add(DictV["GreenV"]);
		BlueV_undo.Add(DictV["BlueV"]);

		////1.3 (limit undo lists' count to num_limit) (unique code block)
		int num_limit = 3;
		if (imgSharplist_undo.Count > num_limit) { imgSharplist_undo.RemoveAt(0); }
		if (IncV_undo.Count > num_limit) { IncV_undo.RemoveAt(0); }
		if (ContrastV_undo.Count > num_limit) { ContrastV_undo.RemoveAt(0); }
		if (BrightnessV_undo.Count > num_limit) { BrightnessV_undo.RemoveAt(0); }
		if (OpacityV_undo.Count > num_limit) { OpacityV_undo.RemoveAt(0); }
		if (RedV_undo.Count > num_limit) { RedV_undo.RemoveAt(0); }
		if (GreenV_undo.Count > num_limit) { GreenV_undo.RemoveAt(0); }
		if (BlueV_undo.Count > num_limit) { BlueV_undo.RemoveAt(0); }

		////1.4 (put this on undo/redo? no)
		if (DictV["IncV"] == 1 && is_FilterIncremental == false)
			Flatten();

	}

	void ClearRedo()
	{
		//List<Image<Rgba32>> imgSharplist_redo = new List<Image<Rgba32>>(); //not working
		imgSharplist_redo = new List<Image<Rgba32>>();
		List<int> IncV_redo = new List<int>();
		List<int> ContrastV_redo = new List<int>();
		List<int> BrightnessV_redo = new List<int>();
		List<int> OpacityV_redo = new List<int>();
		List<int> RedV_redo = new List<int>();
		List<int> GreenV_redo = new List<int>();
		List<int> BlueV_redo = new List<int>();
	}

	void Undo() //need to fix over undoing
	{
		if (displayImage == true && imgSharplist_undo.Count >= 1)
		{
			////1 imgsharp - storing to redo list
			Image<Rgba32> imgSharp_temporary = new Image<Rgba32>(imgSharp.Width, imgSharp.Height);
			for (int y = 0; y < imgSharp_temporary.Height; y++)
			{
				//Span<Rgba32> pixelRowSpan = imgSharp_temporary.GetPixelRowSpan(y);
				for (int x = 0; x < imgSharp_temporary.Width; x++)
				{
					imgSharp_temporary[x, y] = new Rgba32(imgSharp_original2[x, y].R, imgSharp_original2[x, y].G, imgSharp_original2[x, y].B, imgSharp_original2[x, y].A);
				}
			}
			imgSharplist_redo.Add(imgSharp_temporary);

			////1.2 imgsharp's attributes - storing to redo lists
			IncV_redo.Add(DictV["IncV"]);
			ContrastV_redo.Add(DictV["ContrastV"]);
			BrightnessV_redo.Add(DictV["BrightnessV"]);
			OpacityV_redo.Add(DictV["OpacityV"]);
			RedV_redo.Add(DictV["RedV"]);
			GreenV_redo.Add(DictV["GreenV"]);
			BlueV_redo.Add(DictV["BlueV"]);

			////1.3, 1.4 none (no need trim undo/redo lists' count to 3, no need to flatten)

			////2 imgsharp - pulling & deleting from undo list
			for (int y = 0; y < imgSharp_original2.Height; y++)
			{
				Span<Rgba32> pixelRowSpan = imgSharp_original2.GetPixelRowSpan(y);
				for (int x = 0; x < imgSharp_original2.Width; x++)
				{
					Image<Rgba32> undoimage = imgSharplist_undo.ElementAt(imgSharplist_undo.Count - 1);
					pixelRowSpan[x] = new Rgba32(undoimage[x, y].R, undoimage[x, y].G, undoimage[x, y].B, undoimage[x, y].A);
				}
			}
			imgSharplist_undo.RemoveAt(imgSharplist_undo.Count - 1);

			////2 imgsharp's attributes - pulling & deleting from undo lists
			DictV["IncV"] = IncV_undo.ElementAt(IncV_undo.Count - 1);
			DictV["ContrastV"] = ContrastV_undo.ElementAt(ContrastV_undo.Count - 1);
			DictV["BrightnessV"] = BrightnessV_undo.ElementAt(BrightnessV_undo.Count - 1);
			DictV["OpacityV"] = OpacityV_undo.ElementAt(OpacityV_undo.Count - 1);
			DictV["RedV"] = RedV_undo.ElementAt(RedV_undo.Count - 1);
			DictV["GreenV"] = GreenV_undo.ElementAt(GreenV_undo.Count - 1);
			DictV["BlueV"] = BlueV_undo.ElementAt(BlueV_undo.Count - 1);
			IncV_undo.RemoveAt(IncV_undo.Count - 1);
			ContrastV_undo.RemoveAt(ContrastV_undo.Count - 1);
			BrightnessV_undo.RemoveAt(BrightnessV_undo.Count - 1);
			OpacityV_undo.RemoveAt(OpacityV_undo.Count - 1);
			RedV_undo.RemoveAt(RedV_undo.Count - 1);
			GreenV_undo.RemoveAt(GreenV_undo.Count - 1);
			BlueV_undo.RemoveAt(BlueV_undo.Count - 1);

			////3 - apply imgSharp_original2 & new attributes to imgSharp
			ApplyBaseImageAndIncrementalFiltersToCurrentImage();

			////
			JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Contrast", DictV["ContrastV"]);
			JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Brightness", DictV["BrightnessV"]);
			JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Brightness", DictV["OpacityV"]);
			JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Red", DictV["RedV"]);
			JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Green", DictV["GreenV"]);
			JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Blue", DictV["BlueV"]);
		}
	}


	void Redo()
	{
		if (displayImage == true && imgSharplist_redo.Count > 0)
		{
			////1
			Image<Rgba32> imgSharp_temporary = new Image<Rgba32>(imgSharp.Width, imgSharp.Height);
			for (int y = 0; y < imgSharp_temporary.Height; y++)
			{
				//Span<Rgba32> pixelRowSpan = imgSharp_temporary.GetPixelRowSpan(y);
				for (int x = 0; x < imgSharp_temporary.Width; x++)
				{
					imgSharp_temporary[x, y] = new Rgba32(imgSharp_original2[x, y].R, imgSharp_original2[x, y].G, imgSharp_original2[x, y].B, imgSharp_original2[x, y].A);
				}
			}
			imgSharplist_undo.Add(imgSharp_temporary);

			////1.2
			IncV_undo.Add(DictV["IncV"]);
			ContrastV_undo.Add(DictV["ContrastV"]);
			BrightnessV_undo.Add(DictV["BrightnessV"]);
			OpacityV_undo.Add(DictV["OpacityV"]);
			RedV_undo.Add(DictV["RedV"]);
			GreenV_undo.Add(DictV["GreenV"]);
			BlueV_undo.Add(DictV["BlueV"]);

			////1.3, 1.4 none (no need trim undo/redo lists' count to 3, no need to flatten)

			////2 imgsharp - pulling & deleting from redo list
			for (int y = 0; y < imgSharp_original2.Height; y++)
			{
				Span<Rgba32> pixelRowSpan = imgSharp_original2.GetPixelRowSpan(y);
				for (int x = 0; x < imgSharp_original2.Width; x++)
				{
					Image<Rgba32> redoimage = imgSharplist_redo.ElementAt(imgSharplist_redo.Count - 1);
					pixelRowSpan[x] = new Rgba32(redoimage[x, y].R, redoimage[x, y].G, redoimage[x, y].B, redoimage[x, y].A);
				}
			}
			imgSharplist_redo.RemoveAt(imgSharplist_redo.Count - 1);

			////2 imgsharp's attributes - pulling & deleting from redo lists
			DictV["IncV"] = IncV_redo.ElementAt(IncV_redo.Count - 1);
			DictV["ContrastV"] = ContrastV_redo.ElementAt(ContrastV_redo.Count - 1);
			DictV["BrightnessV"] = BrightnessV_redo.ElementAt(BrightnessV_redo.Count - 1);
			DictV["OpacityV"] = OpacityV_redo.ElementAt(OpacityV_redo.Count - 1);
			DictV["RedV"] = RedV_redo.ElementAt(RedV_redo.Count - 1);
			DictV["GreenV"] = GreenV_redo.ElementAt(GreenV_redo.Count - 1);
			DictV["BlueV"] = BlueV_redo.ElementAt(BlueV_redo.Count - 1);
			IncV_redo.RemoveAt(IncV_redo.Count - 1);
			ContrastV_redo.RemoveAt(ContrastV_redo.Count - 1);
			BrightnessV_redo.RemoveAt(BrightnessV_redo.Count - 1);
			OpacityV_redo.RemoveAt(OpacityV_redo.Count - 1);
			RedV_redo.RemoveAt(RedV_redo.Count - 1);
			GreenV_redo.RemoveAt(GreenV_redo.Count - 1);
			BlueV_redo.RemoveAt(BlueV_redo.Count - 1);

			////3 - apply imgSharp_original2 & new attributes to imgSharp
			ApplyBaseImageAndIncrementalFiltersToCurrentImage();

			////
			JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Contrast", DictV["ContrastV"]);
			JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Brightness", DictV["BrightnessV"]);
			JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Brightness", DictV["OpacityV"]);
			JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Red", DictV["RedV"]);
			JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Green", DictV["GreenV"]);
			JS.InvokeVoidAsync("JS_changesliderpositionandtextvalue_Blue", DictV["BlueV"]);
		}
	}


	//public void Dispose()
	//{
	//}

	async Task UploadFile(InputFileChangeEventArgs e)
	{

		displayImage = false;
		showerror = false;
		showloading = true;

		IBrowserFile imageFile = e.File;

		//call javascript function to get file name from inputfile id


		//Debug.WriteLine($"data:{imageType};base64,{Convert.ToBase64String(buffers)}");

		//await using FileStream fs = new(e, System.IO.FileMode.Create);
		//await browserFile.OpenReadStream().CopyToAsync(fs);
		//Debug.WriteLine(imageFile.ContentType);
		//Debug.WriteLine(imageFile.Name);


		if (imageFile != null) // blazorinputfile
		{
			int maxAllowedSize = 15000000;
			imgSharp.Dispose();
			imgSharp_original1.Dispose();
			imgSharp_original2.Dispose();



			//undo lists
			List<Image<Rgba32>> imgSharplist_undo = new List<Image<Rgba32>>();
			List<double> IncV_undo = new List<double>(); //0 = false, 1 = true
			List<double> ContrastV_undo = new List<double>();
			List<double> BrightnessV_undo = new List<double>();
			List<double> OpacityV_undo = new List<double>();
			List<double> RedV_undo = new List<double>();
			List<double> GreenV_undo = new List<double>();
			List<double> BlueV_undo = new List<double>();

			//redo lists
			List<Image<Rgba32>> imgSharplist_redo = new List<Image<Rgba32>>();
			List<double> IncV_redo = new List<double>();
			List<double> ContrastV_redo = new List<double>();
			List<double> BrightnessV_redo = new List<double>();
			List<double> OpacityV_redo = new List<double>();
			List<double> RedV_redo = new List<double>();
			List<double> GreenV_redo = new List<double>();
			List<double> BlueV_redo = new List<double>();

			Dictionary<string, double> DictV = new Dictionary<string, double>();
			DictV.Add("IncV", 0); //0 = false, 1 = true
			DictV.Add("ContrastV", 0);
			DictV.Add("BrightnessV", 0);
			DictV.Add("OpacityV", 0);
			DictV.Add("RedV", 0);
			DictV.Add("GreenV", 0);
			DictV.Add("BlueV", 0);

			////way 1
			//var ms = new MemoryStream(); // blazorinputfile
			////await imageFile.Data.CopyToAsync(ms); // blazorinputfile
			//await imageFile.OpenReadStream().CopyToAsync(ms); // inputfile

			////way 2
			//var ms = new byte[imageFile.Size];
			//await imageFile.OpenReadStream(maxAllowedSize).ReadAsync(ms);

			////way 3
			//await using FileStream buffers = new(e.File.ToString(), FileMode.Create);
			//await imageFile.OpenReadStream(maxAllowedSize).CopyToAsync(buffers);

			////way3.9
			//MemoryStream ms = new MemoryStream();
			//await imageFile.OpenReadStream(maxAllowedSize).CopyToAsync(ms);

			////way4
			//await using MemoryStream ms = new MemoryStream();
			//await imageFile.OpenReadStream(maxAllowedSize).CopyToAsync(ms);

			////way4.1
			await using MemoryStream ms = new MemoryStream();
			await imageFile.OpenReadStream(maxAllowedSize).CopyToAsync(ms);

			//var pngEncoder = new SixLabors.ImageSharp.Formats.Png.PngEncoder();
			//imgSharp.Save(ms, pngEncoder);


			//await JS.InvokeVoidAsync("JS_getfilenamefrominputfile");
			//string imageType;


			try
			{
				//IImageFormat IIF1; // imagesharp

				////way 3 - gives error
				//imgSharp = Image.Load<Rgba32>(buffers, out IIF1); // imagesharp
				//imgSharp_original1 = Image.Load<Rgba32>(buffers, out IIF1);
				//imgSharp_original2 = Image.Load<Rgba32>(buffers, out IIF1);

				////way 4
				//imgSharp = Image.Load<Rgba32>(ms.ToArray(), out IIF1); // imagesharp
				//imgSharp_original1 = Image.Load<Rgba32>(ms.ToArray(), out IIF1);
				//imgSharp_original2 = Image.Load<Rgba32>(ms.ToArray(), out IIF1);

				////way4.1
				using (var imgSharp = Image.Load<Rgba32>((ms.ToArray()))) // imagesharp
				{
					imgSharp.Save("wwwroot/images/download.png");
				}

				imgSharp = Image.Load<Rgba32>("wwwroot/images/download.png", out IIF1);
				imgSharp_original1 = Image.Load<Rgba32>("wwwroot/images/download.png", out IIF1);
				imgSharp_original2 = Image.Load<Rgba32>("wwwroot/images/download.png", out IIF1);


				//imgSharpvHeight = imgSharp.Height; imgSharpvWidth = imgSharp.Width;


				status = $"Finished loading {imageFile.Size} bytes from {imageFile.Name}";

				showloading = false;
				displayImage = true;
				showerror = false;

				//SixLabors.ImageSharp.Formats.Png.PngFormat works with transparency
				//SixLabors.ImageSharp.Formats.Jpeg.JpegFormat does not
			}

			catch (Exception)
			//catch (System.ArgumentException e)
			{
				Error = $"File is not an image (BMP/GIF/JPG/JPEG/PNG/TGA). Try again.";
				showerror = true;
				showloading = false;
			}

		}
		else
		{
			Error = $"Unknown error occurred. Try again.";
			showerror = true;
			showloading = false;
		}


	}

}