@page "/ImageEditor"
@*//NOTES:
    //business-oriented sfotware dev is about making use of tools to help your business stay comopetitive. ex: implement opencv photo filter, etc.
    ////SixLabors.ImageSharp.Formats.Png.PngFormat works with transparency
    //SixLabors.ImageSharp.Formats.Jpeg.JpegFormat does not

    //LIST OF PROBLEMS
    //fix the navbar, check if huesset.com is SSL secured after 24 hours (after 10:40am 5/25) ///PROBLEM 0 (DONE)
    //fix darken/brightness, like make it use centralized variable and original photo ///PROBLEM1
    //need to make every uploaded images act as PNG // //make any photo support ARGB or turn into PNG upon upload (to make ccapable of going transparant) //PROBLEM2
    //update imgSharp_original, should get another imgSharp_original2 to make sure that the reset button works as intended ///PROBLEM3
    //resize/center photo better? off to the right, not well centered ///PROBLEM4
    //how to make gradual increase, not sudden increase throughout range //PROBLEM5

    //Feature Request
    //add button to scroll webpage to exact point for you (helps people scroll to image quickly without using their hands)
    //disable button when image is loading or peocessing (greyed out button)
    //add processing status.. like "processing... estimated time: 10-40 seconds" (add counter)
    //prevent webpage from resetting when exiting or clicking on other tab/button/link, aka keep the state same for x hours maximum
    //descale image
    //add no red/green/blue incremental filter
    //add contrast filter (if grayscale > 128: -20, else if grayscale <= 128: +20)
    //add exposure filer (if grayscale > 128: + 20 // if grayscale > 128: -20)
    //make Reddit/Twitter scraper, build an past-performance analytic (rising mentions vs. stock/crypto price vs. Google trend)
    //add 8/16/...256 color photo filter
    //add gaussian filter
    //add line+shade filter
    //improve navbar to make it only show at the top rather on the side
    //need to accept only pictures; not PDFs, videos, etc. on iPhone

    //implement pan zoom (try timmywill)
    //add 2d spheres
    //add white and black background button
    //add send a message to Patrick's email or database
    //how to make blazor faster, check if SignalR is good to speed up your image editor app, implement SignalR (important)



*@

@*@using BlazorInputFile; obsolate*@
@using System;
@using SixLabors.ImageSharp;
@using System.IO;
@using SixLabors.ImageSharp.Formats;
@using System.Diagnostics;
@using SixLabors.ImageSharp.Processing;
@using SixLabors.ImageSharp.PixelFormats; @*<rgba32>*@
@using BlazorServerApp1;
@using SixLabors.ImageSharp.Memory;
@using System.Runtime.InteropServices; @*memory marhshall*@
@using System.Numerics; @*vector4*@
@using Microsoft.AspNetCore.Hosting;
@*@using Microsoft.AspNetCore.Components.Forms;*@
@using Microsoft.AspNetCore.Components.Forms;


@using Microsoft.Extensions.Logging
@inject IWebHostEnvironment Environment


@code {

    string status = "Sample image";
    string Error;
    bool showerror = false;
    bool showloading = false;
    bool showprocessing = false;
    bool displayImage = false;

    Image<Rgba32> imgSharp;
    Image<Rgba32> imgSharp_original1; //used by reset
    Image<Rgba32> imgSharp_original2; //used by darken/brighten
    Image<Rgba32> imgSharp_original3; //not needed?


    int brightness = 0;


    List<Image<Rgba32>> imgSharplist_undo = new List<Image<Rgba32>>();
    List<Image<Rgba32>> imgSharplist_redo = new List<Image<Rgba32>>();
    List<int> brightnesslist_undo = new List<int>();
    List<int> brightnesslist_redo = new List<int>();


    ImageProcessing_CS _ip;
    ImageProcessing_CS _ip_original;


    IImageFormat IIF1;
    //need to make every uploaded images act as PNG //PROBLEM2
    //IImageFormat format = image.CurrentImageFormat
    //IImageFormat IIF1;
    //IImageFormat IIF2 = SixLabors.ImageSharp.Formats.Png.PngFormat;
    //int num1 = 60;


    //METHOD TO be called first
    //METHOD TO be called first
    void SomeStartupMethod()
    {
        // Do Some Work
        // Make website show uploaded/sample image upon loading
        imgSharp = Image.Load<Rgba32>("wwwroot/images/wlop1.jpg", out IIF1); // imagesharp
        imgSharp_original1 = Image.Load<Rgba32>("wwwroot/images/wlop1.jpg", out IIF1);
        imgSharp_original2 = Image.Load<Rgba32>("wwwroot/images/wlop1.jpg", out IIF1);



        _ip = new ImageProcessing_CS(imgSharp, IIF1); // imagesharp, image for img src
        _ip_original = new ImageProcessing_CS(imgSharp, IIF1);

        displayImage = true;
    }
    Task SomeStartupTask()
    {
        // Do some task based work
        return Task.CompletedTask;
    }
    protected override async Task OnInitializedAsync()
    {
        await Task.Delay(1);
        SomeStartupMethod();
        await SomeStartupTask();
    }
    //METHOD TO be called first
    //METHOD TO be called first
}

<h1>Image Editor</h1>


<form>
    <figcaption>
        Upload an image (10 MB max):
    </figcaption>
    <InputFile id="Upload an image" OnChange="@LoadFiles" />
    @*<InputFile OnChange="@OnInputFileChange" />*@
    @*<p>Upload an image (OLD): <InputFile OnChange="HandleFileSelected_function" /></p>*@
    @*only available in Net 5.0, so use net 5.0 and ensure that ur fully migrated to net 5.0~!!!!*@

    @*<InputFile />
        <button type="submit">Upload Selected File(s)</button>*@
    @*<input multiple="" type="file" _bl_2="">*@
</form>


<div>
    @if (showloading == true)
    {<p style="color:greenyellow">Uploading...</p>}
    @if (showprocessing == true)
    {<p style="color:darkorange">Processing...</p>}
    @if (showerror == true)
    {<p style="color:red">@Error</p>}
    @if (showloading == false)
    {<p>@status</p>}
</div>


<div>
    <figcaption>Filters (more to be added): </figcaption>
    <button class="btn btn-primary" @onclick="Filter1">No Red</button>
    <button class="btn btn-primary" @onclick="Filter2">No Green</button>
    <button class="btn btn-primary" @onclick="Filter3">No Blue</button>
    <button class="btn btn-primary" @onclick="Grayscale">Grayscale</button>
    <br />

    <button class="btn btn-primary" @onclick="Brighten">Brightness (+)</button>
    <button class="btn btn-primary" @onclick="Darken">Brightness (-)</button>
    <br />

    @*<button class="btn btn-primary" @onclick="Opaque">Opacity (+)</button>
        <button class="btn btn-primary" @onclick="Transparent">Opacity (-)</button>
        Note: Opacity adjustment only works on PNG, not JPG/JPEG, for now.
        <br />*@

    @*<button class="btn btn-primary" @onclick="(() => Ray(166))">Ray</button>*@

    <button class="btn btn-primary" @onclick="(() => Edge(0))">Line A</button>
    @*<button class="btn btn-primary" @onclick="(() => Edge(1))">Line B</button>*@
    <button class="btn btn-primary" @onclick="(() => Edge(2))">Line B</button>
    @*<button class="btn btn-primary" @onclick="(() => Edge(3))">Line </button>*@
    <button class="btn btn-primary" @onclick="(() => Edge(4))">Line C</button>
    <br />

    <button class="btn btn-primary" @onclick="Reset">Reset</button>
    <br />

    @*<button class="btn btn-primary">Undo (coming soon)</button>
        <button class="btn btn-primary">Redo (coming soon)</button>
        <br />*@
</div>


@if (displayImage == true)
{
    <p>
        <div>
            @*<img class="image_background" src="@_ip_blank.getBase64String_function()" /> not needed*@
            <img class="image_display"
                 src="@_ip.getBase64String_function()" />
        </div>
    </p>
}
<figure>
    <figcaption>Notes:</figcaption>
    <ul>
        <li>
            If using line filters, use images with high resolution and minimal background for best results.
        </li>
        <li>
            Loading/editing a large image may take >45 seconds due to web app performance limitations.
        </li>
        <li>
            No data gets collected on this site.
        </li>
    </ul>
</figure>


@code {
    //pixel manipulation way 1
    //(not storing variable)
    void Filter1()
    {
        if (displayImage == true)
        {
            for (int w = 0; w < imgSharp.Width; w++)
            {
                for (int h = 0; h < imgSharp.Height; h++)
                {
                    //if (imgSharp[w, h].R < 120)
                    //    imgSharp[w, h] = new Rgba32(255, imgSharp[w, h].G, imgSharp[w, h].B, 255);
                    imgSharp[w, h] = new Rgba32(45, imgSharp_original1[w, h].G, imgSharp_original1[w, h].B, imgSharp_original1[w, h].A);
                }
            }
        }
    }

    //pixel manipulation way 1
    //(storing variable)
    //gives problem, gives white/bright colors (possible solultion, use int and byte) //solved with byte type
    void Filter2()
    {
        if (displayImage == true)
        {
            for (int w = 0; w < imgSharp.Width; w++)
            {
                for (int h = 0; h < imgSharp.Height; h++)
                {
                    //int green = imgSharp[w, h].G - 10;
                    //if (green < 45) { green = 45; }
                    //byte green2 = (byte)green; //use byte
                    //imgSharp[w, h] = new Rgba32(imgSharp[w, h].R, green2, imgSharp[w, h].B, imgSharp[w, h].A);

                    imgSharp[w, h] = new Rgba32(imgSharp_original1[w, h].R, 45, imgSharp_original1[w, h].B, imgSharp_original1[w, h].A);
                }
            }
        }
    }

    //pixel manipulation way 2
    //(not storing variable)
    void Filter3()
    {
        if (displayImage == true)
        {
            for (int y = 0; y < imgSharp.Height; y++)
            {
                Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
                for (int x = 0; x < imgSharp.Width; x++)
                {
                    pixelRowSpan[x] = new Rgba32(imgSharp_original1[x, y].R, imgSharp_original1[x, y].G, 45, imgSharp_original1[x, y].A);
                }
            }
        }
    }

    //pixel manipulation way 2
    //(storing variable)
    public void Darken()
    {
        if (displayImage == true)
        {
            brightness -= 20;
            int red;
            byte red2;
            int green;
            byte green2;
            int blue;
            byte blue2;

            for (int y = 0; y < imgSharp.Height; y++)
            {
                Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
                for (int x = 0; x < imgSharp.Width; x++)
                {
                    red = imgSharp_original1[x, y].R + brightness;
                    green = imgSharp_original1[x, y].G + brightness;
                    blue = imgSharp_original1[x, y].B + brightness;

                    if (red > 255) { red = 255; }
                    else if (red < 0) { red = 0; }
                    if (green > 255) { green = 255; }
                    else if (green < 0) { green = 0; }
                    if (blue > 255) { blue = 255; }
                    else if (blue < 0) { blue = 0; }

                    red2 = (byte)red;
                    green2 = (byte)green;
                    blue2 = (byte)blue;

                    pixelRowSpan[x] = new Rgba32(red2, green2, blue2, imgSharp[x, y].A);
                }
            }
        }
        //Debug.WriteLine(blue);
        //imgSharp_original3 = imgSharp_original2;
    }

    //pixel manipulation way 2
    //(storing variable)
    //fix brighten and darken as color get washed out, maybe stop brightening or darkening if one color reaches 255 or 0, or always start from original image and then adjust it using current "multiplier"
    public void Brighten()
    {
        if (displayImage == true)
        {
            brightness += 20;
            int red;
            byte red2;
            int green;
            byte green2;
            int blue;
            byte blue2;

            for (int y = 0; y < imgSharp.Height; y++)
            {
                Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
                for (int x = 0; x < imgSharp.Width; x++)
                {
                    red = imgSharp_original1[x, y].R + brightness;
                    green = imgSharp_original1[x, y].G + brightness;
                    blue = imgSharp_original1[x, y].B + brightness;

                    if (red > 255) { red = 255; }
                    else if (red < 0) { red = 0; }
                    if (green > 255) { green = 255; }
                    else if (green < 0) { green = 0; }
                    if (blue > 255) { blue = 255; }
                    else if (blue < 0) { blue = 0; }

                    red2 = (byte)red;
                    green2 = (byte)green;
                    blue2 = (byte)blue;

                    pixelRowSpan[x] = new Rgba32(red2, green2, blue2, imgSharp[x, y].A);
                }
            }



        }
        //Debug.WriteLine(blue);
    }


    //pixel manipulation way 2
    //(storing variable)
    public void Opaque()
    {
        if (displayImage == true)
        {
            int alpha;
            byte alpha2;

            for (int y = 0; y < imgSharp.Height; y++)
            {
                Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
                for (int x = 0; x < imgSharp.Width; x++)
                {
                    alpha = imgSharp[x, y].A + 20;
                    if (alpha > 255) { alpha = 255; }
                    else if (alpha < 0) { alpha = 0; }
                    alpha2 = (byte)alpha;

                    pixelRowSpan[x] = new Rgba32(imgSharp[x, y].R, imgSharp[x, y].G, imgSharp[x, y].B, alpha2);
                }
            }
        }
        //imgSharp_original2 = imgSharp;
    }


    //pixel manipulation way 2
    //(storing variable)
    public void Transparent()
    {
        if (displayImage == true)
        {
            int alpha;
            byte alpha2;

            for (int y = 0; y < imgSharp.Height; y++)
            {
                Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
                for (int x = 0; x < imgSharp.Width; x++)
                {
                    alpha = imgSharp[x, y].A - 20;
                    if (alpha > 255) { alpha = 255; }
                    else if (alpha < 0) { alpha = 0; }
                    alpha2 = (byte)alpha;

                    pixelRowSpan[x] = new Rgba32(imgSharp[x, y].R, imgSharp[x, y].G, imgSharp[x, y].B, alpha2);
                }
            }
        }
        //imgSharp_original2 = imgSharp;
    }


    //pixel manipulation way 1
    //(storing variable)
    //grayscale filter
    void Grayscale()
    {
        if (displayImage == true)
        {
            for (int w = 0; w < imgSharp.Width; w++)
            {
                for (int h = 0; h < imgSharp.Height; h++)
                {
                    int bwcolor = (imgSharp_original1[w, h].R + imgSharp_original1[w, h].G + imgSharp_original1[w, h].B) / 3;
                    byte bwcolor2 = (byte)bwcolor;

                    imgSharp[w, h] = new Rgba32(bwcolor2, bwcolor2, bwcolor2, imgSharp[w, h].A);
                }
            }
        }
        //imgSharp = imgSharp_original;
        //imgSharp.Mutate(x => x.Grayscale());
    }


    void Ray(int n1)
    {
        int red = 0;
        byte red2 = 0;
        int green = 0;
        byte green2 = 0;
        int blue = 0;
        byte blue2 = 0;
        for (int y = 0; y < imgSharp.Height; y++)
        {
            Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
            for (int x = 0; x < imgSharp.Width; x++)
            {
                blue = imgSharp[x, y].B;
                green = imgSharp[x, y].G;
                red = imgSharp[x, y].R;

                //int n1 = 230;
                int n2 = 230;
                if (blue >= n1 && blue <= n2) { blue += 0; }
                if (green >= n1 && green <= n2) { green += 0; }
                if (red >= n1 && red <= n2) { red += 30; }




                if (red > 255) { red = 255; }
                else if (red < 0) { red = 0; }
                if (green > 255) { green = 255; }
                else if (green < 0) { green = 0; }
                if (blue > 255) { blue = 255; }
                else if (blue < 0) { blue = 0; }

                red2 = (byte)red;
                green2 = (byte)green;
                blue2 = (byte)blue;

                pixelRowSpan[x] = new Rgba32(red2, blue2, blue2, imgSharp[x, y].A);
            }
        }
    }


    //WIP, use way 2,
    //works on small image
    void Edge(int parameter1)
    {
        if (displayImage == true)
        {
            showprocessing = true;
            int height = imgSharp.Height - 1;
            int width = imgSharp.Width - 1; //preivious -1


            int[,] array_gx = new int[3, 3];
            int[,] array_gy = new int[3, 3];


            //prewitt

            if (parameter1 == 0)
            {
                //sobel
                array_gx[0, 0] = -1; array_gx[0, 1] = 0; array_gx[0, 2] = 1;
                array_gx[1, 0] = -2; array_gx[1, 1] = 0; array_gx[1, 2] = 2;
                array_gx[2, 0] = -1; array_gx[2, 1] = 0; array_gx[2, 2] = 1;
                array_gy[0, 0] = -1; array_gy[0, 1] = -2; array_gy[0, 2] = -1;
                array_gy[1, 0] = 0; array_gy[1, 1] = 0; array_gy[1, 2] = 0;
                array_gy[2, 0] = 1; array_gy[2, 1] = 2; array_gy[2, 2] = 1;
            }
            else if (parameter1 == 1 || parameter1 == 2 || parameter1 == 3)
            {
                //alternative, prewitt?, more intense
                array_gx[0, 0] = -2; array_gx[0, 1] = 0; array_gx[0, 2] = 2;
                array_gx[1, 0] = -2; array_gx[1, 1] = 0; array_gx[1, 2] = 2;
                array_gx[2, 0] = -2; array_gx[2, 1] = 0; array_gx[2, 2] = 2;
                array_gy[0, 0] = -2; array_gy[0, 1] = -2; array_gy[0, 2] = -2;
                array_gy[1, 0] = 0; array_gy[1, 1] = 0; array_gy[1, 2] = 0;
                array_gy[2, 0] = 2; array_gy[2, 1] = 2; array_gy[2, 2] = 2;
            }
            else if (parameter1 == 4)
            {
                //alternative, prewitt?, more intense
                array_gx[0, 0] = 5; array_gx[0, 1] = 5; array_gx[0, 2] = 5;
                array_gx[1, 0] = -3; array_gx[1, 1] = 0; array_gx[1, 2] = -3;
                array_gx[2, 0] = -3; array_gx[2, 1] = -3; array_gx[2, 2] = -3;
                array_gy[0, 0] = 5; array_gy[0, 1] = -3; array_gy[0, 2] = -3;
                array_gy[1, 0] = 5; array_gy[1, 1] = 0; array_gy[1, 2] = -3;
                array_gy[2, 0] = 5; array_gy[2, 1] = -3; array_gy[2, 2] = -3;
            }


            //init
            int val_Alpha = 0;
            byte val_Alpha2 = 0;

            int val_Blue = 0;
            int val_Green = 0;
            int val_Red = 0;

            int Gx_sum_Blue = 0;
            int Gx_sum_Green = 0;
            int Gx_sum_Red = 0;

            int Gy_sum_Blue = 0;
            int Gy_sum_Green = 0;
            int Gy_sum_Red = 0;

            int Gxy_sum_final_Blue = 0;
            int Gxy_sum_final_Green = 0;
            int Gxy_sum_final_Red = 0;

            //int logprint_sum1 = 0;



            for (int y = 0; y <= height; y++)
            {
                if (y == 0) { continue; }
                if (y == height - 1) { continue; }
                if (y == height) { continue; }
                Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
                for (int x = 0; x <= width; x++)
                {
                    if (x == 0) { continue; }
                    if (x == width - 1) { continue; }
                    if (x == width) { continue; }

                    Gx_sum_Blue = 0;
                    Gx_sum_Green = 0;
                    Gx_sum_Red = 0;

                    Gy_sum_Blue = 0;
                    Gy_sum_Green = 0;
                    Gy_sum_Red = 0;

                    Gxy_sum_final_Blue = 0;
                    Gxy_sum_final_Green = 0;
                    Gxy_sum_final_Red = 0;

                    //// finding Gx and Gy
                    //// finding Gx and Gy
                    for (int r = 0; r < 3; r++)
                    {
                        for (int c = 0; c < 3; c++)
                        {
                            //fix this part, so it can work on any image on BS1 app
                            if (((y + (r - 1) >= 0) && (x + (c - 1) >= 0)) && ((y + (r - 1) <= height) && (x + (c - 1) <= width)))
                            {
                                int he = y + (r - 1);
                                int we = x + (c - 1);

                                //val_Blue = imgSharp[he, we].B;
                                //val_Green = imgSharp[he, we].G;
                                //val_Red = imgSharp[he, we].R;

                                val_Blue = imgSharp_original1[we, he].B;
                                val_Green = imgSharp_original1[we, he].G;
                                val_Red = imgSharp_original1[we, he].R;
                            }
                            //fix this part, so it can work on any image on BS1 app


                            // if outside the border (row)
                            if ((y + (r - 1) < 0) || (y + (r - 1) > (height - 1)))
                            {
                                val_Blue = 0;
                                val_Green = 0;
                                val_Red = 0;
                                //logprint_sum1++; //2400
                            }

                            // if outside the border (column)
                            // 400
                            else if ((x + (c - 1) < 0) || (x + (c - 1) > (width - 1)))
                            {
                                val_Blue = 0;
                                val_Green = 0;
                                val_Red = 0;
                                //logprint_sum1++; //3290
                            }

                            Gx_sum_Blue += val_Blue * array_gx[r, c];
                            Gx_sum_Green += val_Green * array_gx[r, c];
                            Gx_sum_Red += val_Red * array_gx[r, c];

                            Gy_sum_Blue += val_Blue * array_gy[r, c];
                            Gy_sum_Green += val_Green * array_gy[r, c];
                            Gy_sum_Red += val_Red * array_gy[r, c];

                        }
                    }
                    //// finding Gx and Gy
                    //// finding Gx and Gy



                    //store alpha for desired modification
                    val_Alpha = imgSharp[x, y].A;

                    Gxy_sum_final_Blue = (int)Math.Sqrt(((Math.Pow(Gx_sum_Blue, 2)) + (Math.Pow(Gy_sum_Blue, 2))));
                    Gxy_sum_final_Green = (int)(Math.Sqrt((Math.Pow(Gx_sum_Green, 2)) + (Math.Pow(Gy_sum_Green, 2))));
                    Gxy_sum_final_Red = (int)Math.Sqrt(((Math.Pow(Gx_sum_Red, 2)) + (Math.Pow(Gy_sum_Red, 2))));


                    ////modification BEG
                    ////modification BEG


                    //make weak white lines stronger (applies to black background/white line, non-invert) //way 2

                    double m1 = 1.33; //0.5 darker, 1 normal, 2 whiter //BUTTON/SLIDER HERE!!!!
                    if (parameter1 == 4 || parameter1 == 1) { m1 = 1; }
                    if (Gxy_sum_final_Blue >= 45 && Gxy_sum_final_Blue <= 160) { Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue * m1); }
                    if (Gxy_sum_final_Green >= 45 && Gxy_sum_final_Green <= 160) { Gxy_sum_final_Green = (int)(Gxy_sum_final_Green * m1); }
                    if (Gxy_sum_final_Red >= 45 && Gxy_sum_final_Red <= 160) { Gxy_sum_final_Red = (int)(Gxy_sum_final_Red * m1); }
                    //make strong white lines weaker (applies to black background/white line, non-invert) //way 2
                    double m2 = 0.90; //0.90 //BUTTON/SLIDER HERE!!!
                    if (Gxy_sum_final_Blue >= 180 && Gxy_sum_final_Blue <= 230) { Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue * m2); }
                    if (Gxy_sum_final_Green >= 180 && Gxy_sum_final_Green <= 230) { Gxy_sum_final_Green = (int)(Gxy_sum_final_Green * m2); }
                    if (Gxy_sum_final_Red >= 180 && Gxy_sum_final_Red <= 230) { Gxy_sum_final_Red = (int)(Gxy_sum_final_Red * m2); }


                    //ui idea
                    //idea: set a range (ex: 80-200) for weak white lines to get whiter
                    //idea: set another range (ex: 200-255) for strong white lines to get darker
                    ////modification END
                    ////modification END








                    //////custom color background
                    int cutoff = 15; //should try make a slider ouit of this //IDEA1 //make alpha=0 background //30, 45, 60, 75
                    if (parameter1 == 1) { cutoff = 60; }
                    if (Gxy_sum_final_Blue <= cutoff && Gxy_sum_final_Green <= cutoff && Gxy_sum_final_Red <= cutoff)
                    {

                        Gxy_sum_final_Blue = 0;
                        Gxy_sum_final_Green = 0;
                        Gxy_sum_final_Red = 0;
                    }
                    else
                    {
                        //if (Gxy_sum_final_Blue < cutoff) { Gxy_sum_final_Blue = cutoff; }
                        //if (Gxy_sum_final_Green < cutoff) { Gxy_sum_final_Green = cutoff; }
                        //if (Gxy_sum_final_Red < cutoff) { Gxy_sum_final_Red = cutoff; }
                        //Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue * 1.33);
                        //Gxy_sum_final_Green = (int)(Gxy_sum_final_Green * 1.33);
                        //Gxy_sum_final_Red = (int)(Gxy_sum_final_Red * 1.33);
                    }
                    //OR..
                    //////..transparant (before invert)
                    //int cutoff = 128; //should try make a slider ouit of this //IDEA1 //make alpha=0 background //180 FOR TRANSPARRENCY
                    //if (Gxy_sum_final_Blue <= cutoff && Gxy_sum_final_Green <= cutoff && Gxy_sum_final_Red <= cutoff)
                    //{
                    //    val_Alpha = 0;
                    //}
                    //else
                    //{
                    //    //if (Gxy_sum_final_Blue < cutoff) { Gxy_sum_final_Blue = cutoff; }
                    //    //if (Gxy_sum_final_Green < cutoff) { Gxy_sum_final_Green = cutoff; }
                    //    //if (Gxy_sum_final_Red < cutoff) { Gxy_sum_final_Red = cutoff; }
                    //    Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue * 1/0.20); //should make sliders out of these //IDEA2 ex: 100% = 1, 200% = 2
                    //    Gxy_sum_final_Green = (int)(Gxy_sum_final_Green * 1/0.20);
                    //    Gxy_sum_final_Red = (int)(Gxy_sum_final_Red * 1/0.20);
                    //}


                    //keep ARGB within 0-255
                    if (Gxy_sum_final_Blue > 255) { Gxy_sum_final_Blue = 255; }
                    if (Gxy_sum_final_Green > 255) { Gxy_sum_final_Green = 255; }
                    if (Gxy_sum_final_Red > 255) { Gxy_sum_final_Red = 255; }
                    if (Gxy_sum_final_Blue < 0) { Gxy_sum_final_Blue = 0; }
                    if (Gxy_sum_final_Green < 0) { Gxy_sum_final_Green = 0; }
                    if (Gxy_sum_final_Red < 0) { Gxy_sum_final_Red = 0; }


                    //modification BEG
                    //modification BEG
                    //INVERT
                    Gxy_sum_final_Red = 255 - Gxy_sum_final_Red;
                    Gxy_sum_final_Green = 255 - Gxy_sum_final_Green;
                    Gxy_sum_final_Blue = 255 - Gxy_sum_final_Blue;



                    //////////..transparant (after invert)
                    //int cutoff = 128; //should try make a slider ouit of this //IDEA1 //make alpha=0 background //180 FOR TRANSPARRENCY
                    //if (Gxy_sum_final_Blue >= cutoff && Gxy_sum_final_Blue >= cutoff && Gxy_sum_final_Blue >= cutoff)
                    //{
                    //    val_Alpha = 0;
                    //}
                    //else
                    //{
                    //    Gxy_sum_final_Blue = (int)(Gxy_sum_final_Blue * 0.90); //should make sliders out of these //IDEA2 ex: 100% = 1, 200% = 2
                    //    Gxy_sum_final_Green = (int)(Gxy_sum_final_Green * 0.90);
                    //    Gxy_sum_final_Red = (int)(Gxy_sum_final_Red * 0.90);
                    //    //if (Gxy_sum_final_Blue > cutoff) { Gxy_sum_final_Blue = cutoff; }
                    //    //if (Gxy_sum_final_Green > cutoff) { Gxy_sum_final_Green = cutoff; }
                    //    //if (Gxy_sum_final_Red > cutoff) { Gxy_sum_final_Red = cutoff; }
                    //}




                    //No BW and/or shade way 0

                    if (parameter1 == 1 || parameter1 == 0)
                    {
                        ////Make BW only way 1
                        int bwcolor = (Gxy_sum_final_Blue + Gxy_sum_final_Green + Gxy_sum_final_Red) / 3;
                        Gxy_sum_final_Blue = bwcolor;
                        Gxy_sum_final_Green = bwcolor;
                        Gxy_sum_final_Red = bwcolor;
                    }

                    //OR
                    else if (parameter1 == 2)
                    {
                        //Make BW + shade way 2
                        int bwcolor = (Gxy_sum_final_Blue + Gxy_sum_final_Green + Gxy_sum_final_Red) / 3;
                        int bwcolor2 = (int)(((imgSharp_original1[x, y].R + imgSharp_original1[x, y].G + imgSharp_original1[x, y].B) / 3) * 1.0);
                        //if (bwcolor2 > 255) { bwcolor = 255; }
                        //if (bwcolor2 < 0) { bwcolor = 0; }
                        //add shade
                        if (bwcolor2 <= bwcolor && bwcolor2 <= 230)
                        {
                            Gxy_sum_final_Blue = bwcolor2;
                            Gxy_sum_final_Green = bwcolor2;
                            Gxy_sum_final_Red = bwcolor2;
                        }
                        else
                        {
                            Gxy_sum_final_Blue = bwcolor;
                            Gxy_sum_final_Green = bwcolor;
                            Gxy_sum_final_Red = bwcolor;
                        }
                    }


                    else if (parameter1 == 3)
                    {
                        ////Make shade way 3
                        //double adj1 = 1.3;
                        //double adj2 = 0; //no needed, probably just use white line whitener, dark spot darker block-of-code from earlier
                        //int bwcolor = (int)(Gxy_sum_final_Blue + Gxy_sum_final_Green + Gxy_sum_final_Red) / 3;
                        //int bwcolor2 = (int)(((imgSharp_original1[x, y].R + imgSharp_original1[x, y].G + imgSharp_original1[x, y].B) / 3) * adj1); //0.60 to cheat
                        //if (bwcolor2 > 255) { bwcolor = 255; }
                        //if (bwcolor2 < 0) { bwcolor = 0; }
                        //if (bwcolor2 <= bwcolor)
                        //{
                        //    Gxy_sum_final_Blue = (int)(imgSharp_original1[x, y].B * adj1);
                        //    Gxy_sum_final_Green = (int)(imgSharp_original1[x, y].G * adj1);
                        //    Gxy_sum_final_Red = (int)(imgSharp_original1[x, y].R * adj1);
                        //}
                        //else
                        //{
                        //    Gxy_sum_final_Blue = (int)(bwcolor - adj2);
                        //    Gxy_sum_final_Green = (int)(bwcolor - adj2);
                        //    Gxy_sum_final_Red = (int)(bwcolor - adj2);
                        //}

                        ////Make shade way 3.2
                        int bwcolor = (Gxy_sum_final_Blue + Gxy_sum_final_Green + Gxy_sum_final_Red) / 3;
                        int bwcolor2 = (int)(((imgSharp_original1[x, y].R + imgSharp_original1[x, y].G + imgSharp_original1[x, y].B) / 3) * 1.0);
                        //if (bwcolor2 > 255) { bwcolor = 255; }
                        //if (bwcolor2 < 0) { bwcolor = 0; }
                        //add shade
                        if (bwcolor2 <= bwcolor && bwcolor2 <= 255)
                        {
                            Gxy_sum_final_Blue = imgSharp_original1[x, y].B;
                            Gxy_sum_final_Green = imgSharp_original1[x, y].G;
                            Gxy_sum_final_Red = imgSharp_original1[x, y].R;
                        }
                        else
                        {
                            Gxy_sum_final_Blue = bwcolor;
                            Gxy_sum_final_Green = bwcolor;
                            Gxy_sum_final_Red = bwcolor;
                        }
                    }

                    else if (parameter1 == 4)
                    {
                        //ray effect way 4 = from way 1, grayscale with color lines
                        ////Make BW
                        int bwcolor = (Gxy_sum_final_Blue + Gxy_sum_final_Green + Gxy_sum_final_Red) / 3;
                        Gxy_sum_final_Blue = bwcolor;
                        Gxy_sum_final_Green = bwcolor;
                        Gxy_sum_final_Red = bwcolor;

                        int bwcolor2 = (((imgSharp_original1[x, y].R + imgSharp_original1[x, y].G + imgSharp_original1[x, y].B) / 3));
                        //add shade
                        if (bwcolor2 <= bwcolor)
                        {
                            Gxy_sum_final_Blue = bwcolor2;


                        }
                        Gxy_sum_final_Green = bwcolor2;
                        Gxy_sum_final_Red = bwcolor2;


                    }




                    //modification END
                    //modification END


                    //keep ARGB within 0-255
                    if (Gxy_sum_final_Blue > 255) { Gxy_sum_final_Blue = 255; }
                    if (Gxy_sum_final_Green > 255) { Gxy_sum_final_Green = 255; }
                    if (Gxy_sum_final_Red > 255) { Gxy_sum_final_Red = 255; }
                    if (Gxy_sum_final_Blue < 0) { Gxy_sum_final_Blue = 0; }
                    if (Gxy_sum_final_Green < 0) { Gxy_sum_final_Green = 0; }
                    if (Gxy_sum_final_Red < 0) { Gxy_sum_final_Red = 0; }






                    //recreate with byte variables cuz ImageSharp
                    byte Gxy_sum_final_Red2 = (byte)Gxy_sum_final_Red;
                    byte Gxy_sum_final_Green2 = (byte)Gxy_sum_final_Green;
                    byte Gxy_sum_final_Blue2 = (byte)Gxy_sum_final_Blue;
                    val_Alpha2 = (byte)val_Alpha;





                    pixelRowSpan[x] = new Rgba32(Gxy_sum_final_Red2, Gxy_sum_final_Green2, Gxy_sum_final_Blue2, val_Alpha2);
                }
            }

            ////update imgSharp_original, should get another imgSharp_original2 to make sure that the reset button works as intended ///PROBLEM3
            //imgSharp_original1 = imgSharp;

        }
        showprocessing = false;
    }


    void Undo()
    {
        if (displayImage == true)
        {
        }
    }


    void Redo()
    {
        if (displayImage == true)
        {
        }
    }


    void Reset()
    {
        if (displayImage == true)
        {
            for (int y = 0; y < imgSharp.Height; y++)
            {
                Span<Rgba32> pixelRowSpan = imgSharp.GetPixelRowSpan(y);
                for (int x = 0; x < imgSharp.Width; x++)
                {
                    pixelRowSpan[x] = new Rgba32(imgSharp_original1[x, y].R, imgSharp_original1[x, y].G, imgSharp_original1[x, y].B, imgSharp_original1[x, y].A);
                }
            }
        }
    }


    public void Dispose()
    {
    }


    string Message = "No file(s) selected";
    IReadOnlyList<IBrowserFile> selectedFiles;


    private List<IBrowserFile> loadedFiles = new();
    private long maxFileSize = 1024 * 15;
    private int maxAllowedFiles = 1;
    private bool isLoading;

    //async Task LoadFiles(InputFileChangeEventArgs e)

    //{
    //    showloading = true;
    //    displayImage = false;
    //    showerror = true;

    //    //var imageFile = e.();

    //    foreach (var file in e.GetMultipleFiles(maxAllowedFiles))
    //    {
    //        try
    //        {
    //            loadedFiles.Add(file);

    //            var trustedFileNameForFileStorage = Path.GetRandomFileName();
    //            var path = Path.Combine(Environment.ContentRootPath,
    //                    Environment.EnvironmentName, "unsafe_uploads",
    //                    trustedFileNameForFileStorage);

    //            //await using FileStream fs = new(path, FileMode.Create);
    //            //await file.OpenReadStream(maxFileSize).CopyToAsync(fs);


    //            var ms = new MemoryStream(); // blazorinputfile

    //            await file.OpenReadStream(maxFileSize).CopyToAsync(ms); // blazorinputfile

    //            try
    //            {
    //                IImageFormat IIF1; // imagesharp
    //                imgSharp = Image.Load<Rgba32>(ms.ToArray(), out IIF1); // imagesharp
    //                imgSharp_original1 = Image.Load<Rgba32>(ms.ToArray(), out IIF1);

    //                _ip = new ImageProcessing_CS(imgSharp, IIF1); // imagesharp, image for img src
    //                _ip_original = new ImageProcessing_CS(imgSharp, IIF1);


    //                status = $"Finished loading {file.Size} bytes from {file.Name}";
    //                showloading = false;
    //                displayImage = true;
    //                showerror = false;


    //                //Debug.WriteLine(IIF1);


    //            }


    //            catch (Exception x)
    //            //catch (System.ArgumentException e)
    //            {
    //                Error = $"Error occured while loading image. {x.Message}(1)";
    //                showerror = true;
    //                showloading = false;
    //            }
    //        }
    //        catch (Exception ex)
    //        {
    //        }
    //    }


    //    Debug.WriteLine("OnInputFile change activated");

    //}



    async Task LoadFiles(InputFileChangeEventArgs e)
    {

        displayImage = false;
        showerror = false;
        showloading = true;


        IBrowserFile imageFile = e.File;


        //string imageType = imageFile.ContentType;
        //Debug.WriteLine($"data:{imageType};base64,{Convert.ToBase64String(buffers)}");


        //await using FileStream fs = new(e, System.IO.FileMode.Create);
        //await browserFile.OpenReadStream().CopyToAsync(fs);


        if (imageFile != null) // blazorinputfile
        {
            ////way 1
            //var ms = new MemoryStream(); // blazorinputfile
            ////await imageFile.Data.CopyToAsync(ms); // blazorinputfile
            //await imageFile.OpenReadStream().CopyToAsync(ms); // inputfile

            ////way 2
            //var ms = new byte[imageFile.Size];
            //await imageFile.OpenReadStream().ReadAsync(ms);

            ////way3
            //await using FileStream ms = new(e.File, FileMode.Create);
            //await using MemoryStream ms = new MemoryStream();
            //await imageFile.OpenReadStream().CopyToAsync(ms);

            //way4
            int maxAllowedSize = 10000000;
            MemoryStream ms = new MemoryStream();
            await imageFile.OpenReadStream(maxAllowedSize).CopyToAsync(ms);
            try
            {

                IImageFormat IIF1; // imagesharp
                                   ////way 1
                imgSharp = Image.Load<Rgba32>(ms.ToArray(), out IIF1); // imagesharp
                imgSharp_original1 = Image.Load<Rgba32>(ms.ToArray(), out IIF1);
                imgSharp_original2 = Image.Load<Rgba32>(ms.ToArray(), out IIF1);
                ////way 2
                //imgSharp = Image.Load<Rgba32>(buffers, out IIF1); // imagesharp
                //imgSharp_original1 = Image.Load<Rgba32>(buffers,out IIF1);


                _ip = new ImageProcessing_CS(imgSharp, IIF1); // imagesharp, image for img src
                _ip_original = new ImageProcessing_CS(imgSharp, IIF1);


                status = $"Finished loading {imageFile.Size} bytes from {imageFile.Name}";


                showloading = false;
                displayImage = true;
                showerror = false;


                //Debug.WriteLine(IIF1);

                //SixLabors.ImageSharp.Formats.Png.PngFormat works with transparency
                //SixLabors.ImageSharp.Formats.Jpeg.JpegFormat does not
            }


            catch (Exception x)
            //catch (System.ArgumentException e)
            {
                Error = $"File is not an image (BMP/GIF/JPG/JPEG/PNG/TGA). Try again.";
                showerror = true;
                showloading = false;
            }

        }
        else
        {
            Error = $"Unknown error occurred. Try again.";
            showerror = true;
            showloading = false;
        }


    }


    ////// replace this file upload BEG
    ////// replace this file upload
    ////// replace this file upload

    // Uncaught(in promise) Error: Error: System.ArgumentException: There is no tracked object with id '1'. Perhaps the DotNetObjectReference instance was already disposed. (Parameter 'dotNetObjectId')
    //at Microsoft.JSInterop.JSRuntime.GetObjectReference(Int64 dotNetObjectId)
    //at Microsoft.JSInterop.Infrastructure.DotNetDispatcher.BeginInvokeDotNet(JSRuntime jsRuntime, DotNetInvocationInfo invocationInfo, String argsJson)
    // at inputfile.js:32


    //use blazorinputfile extension nuget
    ////take in file input and create imagesharp
    //async Task OnInputFileChange(InputFileChangeEventArgs e)
    ////async Task LoadFiles(InputFileChangeEventArgs e)
    ////async Task HandleFileSelected_function(IFileListEntry[] files) // blazorinputfile
    //{

    //    displayImage = false;
    //    showerror = false;
    //    showloading = true;

    //    var imageFile = files.FirstOrDefault(); // blazorinputfile, firstordefault = default returns null
    //                                            //var imageFile = files.First(); // blazorinputfile

    //    if (imageFile.Type == "image/jpeg" || imageFile.Type == "image/png" || imageFile.Type == "image/jpg" || imageFile.Type == "image/jiff" || imageFile.Type == "image/bmp")
    //    {
    //        if (imageFile != null) // blazorinputfile
    //        {
    //            var ms = new MemoryStream(); // blazorinputfile
    //            await imageFile.Data.CopyToAsync(ms); // blazorinputfile

    //            ///ADDED
    //            try
    //            {
    //                IImageFormat IIF1; // imagesharp
    //                imgSharp = Image.Load<Rgba32>(ms.ToArray(), out IIF1); // imagesharp
    //                imgSharp_original1 = Image.Load<Rgba32>(ms.ToArray(), out IIF1);

    //                _ip = new ImageProcessing_CS(imgSharp, IIF1); // imagesharp, image for img src
    //                _ip_original = new ImageProcessing_CS(imgSharp, IIF1);


    //                status = $"Finished loading {imageFile.Size} bytes from {imageFile.Name}";
    //                showloading = false;
    //                displayImage = true;
    //                showerror = false;


    //                //Debug.WriteLine(IIF1);

    //                //SixLabors.ImageSharp.Formats.Png.PngFormat works with transparency
    //                //SixLabors.ImageSharp.Formats.Jpeg.JpegFormat does not
    //            }


    //            catch (Exception e)
    //            //catch (System.ArgumentException e)
    //            {
    //                Error = $"Error occured while loading image. {e.Message}(1)";
    //                showerror = true;
    //                showloading = false;

    //                imageFile = files.FirstOrDefault();

    //            }

    //        }
    //        else
    //        {
    //            Error = $"Unknown error occurred. Try refreshing. (2)";
    //            showerror = true;
    //            showloading = false;
    //        }
    //    }


    //    else
    //    {
    //        Error = $"Error: File is not JPEG/JPG/PNG/JIFF/BMP image. (3)";
    //        showerror = true;
    //        showloading = false;
    //    }


    //}

    ////// replace this file upload END
    ////// replace this file upload
    ////// replace this file upload
    //////


}
